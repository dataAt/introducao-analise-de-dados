# Introdução ao Python `r emo::ji("rocket")`

Python é uma linguagem multiparadigma, com uma sintaxe simples que permite ao utilizador focar no problema e deixar de lado qualquer tipo de especificidade. A linguagem vem sendo amplamente utilizada em diversas áreas, por conta das milhares de bibliotecas que possui, boa parte dessas distribuídas pela incrível comunidade da linguagem `r emo::ji("heart")`.

Nesta introdução, o foco será a aplicação da linguagem Python na manipulação e tratamento de dados, utilizando como base a biblioteca Pandas.

Você pode estar se perguntando o motivo da utilização desta biblioteca e a resposta é bem simples, Python é uma linguagem de uso geral, assim, suas funções nativas não tem foco em uma aplicação específica, como acontece em linguagens como R e Julia, que possuem áreas específicas de aplicação. Com isso, não podemos esperar que nativamente a linguagem tenha métodos variados para a manipulação e tratamento de dados e é nesta parte que o Pandas entra, facilitando toda manipulação e tratamento de dados com funções incríveis.

Vamos começar !

## Introdução ao Pandas `r emo::ji("panda_face")`

Para iniciar, vamos entender o que é a biblioteca Pandas e qual seu objetivo geral, para isto, vejamos a definição feita na documentação oficial do projeto.

> Pandas é uma biblioteca open source, licenciada pelo BSD, que fornece estruturas de dados de alto desempenho e fáceis de usar e ferramentas de análise de dados para a linguagem de programação Python.

Veja então que, tudo o que é necessário para a realização da maioria dos casos de análise de dados utilizando a linguagem Python, irão, bem provavelmente, trabalhar com esta biblioteca.

Para que se tenha uma ideia, o Pandas pode ser aplicado em análises envolvendo:

- Finanças;
- Geociências;
- Ciência social;
- Além de diversas outras áreas de ciências e engenharia.

Isto tudo por contar com diversas funções e estruturas de dados que facilitam os processos de análise, essas discutidas nos próximos tópicos. 

## Estruturas de dados

O Pandas disponibiliza diversas estruturas de dados preparadas para o trabalho com grandes volumes de dados, sendo as principais:

- Series;
- DataFrames.

Nos subtópicos abaixo vamos ver as características de cada uma destas estruturas, e em seguida, veremos alguns utilitários para leitura dos dados com Pandas.

### Series

As `Series` são estruturas de dados unidimensionais, que contam com diversos métodos para a manipulação de dados.
Pode-se entender que as `Series` são estruturas de dados simples, assim como as listas padrões da linguagem Python, com uma pequena diferença, para cada item dentro de uma `Series` tem-se índices.

Para entendermos, vamos começar com a utilização desta estrutura de dados

```{r, echo=FALSE}
# Estes comandos não devem ser executados em seu terminal
library(reticulate) 
use_python("venv/bin/python3")
```

Inicialmente, faça a importação da biblioteca pandas com o 'apelido' de `pd`, em seguida, vamos criar uma `Series` simples, passando como parâmetro de entrada uma lista com três valores, veja:

```{python}
import pandas as pd

s = pd.Series([1, 2, 3]); print(s)
```

> Ao fazer pd.Series, você está explicitamente informando que a estrutura de dados `Series` está no contexto da biblioteca Pandas

É interessante notar o índice na `Series`, citado anteriormente, que permite a recuperação rápida e simples dos dados. A recuperação feita através de índices é muito parecida com a recuperação de valores em um dicionário em Python, veja:

```{python}
print(s[0]) # Recupera o valor do índice com nome 0
```

Para visualizar somente o índice, utilizamos o atributo `index`.

```{python}
print(s.index)
```

O índice pode ser facilmente editado

```{python}
s.index = ["um", "dois", "tres"]

print(s.index)
```

Também é possível já criar uma `Series` com um índice personalizado, para isto, basta passar no construtor uma lista representado o índice, veja:

```{python}
s = pd.Series([7, 8, 9], [1, 2, 3])

# ou
s = pd.Series([7, 8, 9], index=[1, 2, 3]) # Fica explicito quem é o índice
```

Veja que a primeira lista passada representa os dados, e a segunda o índice

```{python}
print(s)
```

É possível também transformar facilmente os dicionários em `Series`.

```{python}
dicto = {
  'instituto': 'INPE',
  'nota': 10
}

dicto_s = pd.Series(dicto); print(dicto_s)
```

Após a conversão o uso é basicamente o mesmo do dicionário. Além do que já foi dito sobre as `Series`, é importante lembrar que, estas estruturas de dados possuem diversos métodos para facilitar a manipulação e entendimento dos dados, apresentados nas próximas seções.

Mesmo as `Series` sendo estruturas de dados poderosas, elas apresentam a limitação da unidimensionalidade, o que impede matrizes, tabelas e similares não possam ser facilmente representadas através das `Series`. Para esta limitação ficar clara, vamos inserir uma matriz de dados em uma `Series`, erros não serão apresentados, porém a representação pode não ficar como desejado.

```{python}
matriz = pd.Series([[1, 2, 3], [4, 5, 6]])
print(matriz)
```

Percebeu ? Não há uma matriz, e sim várias listas dentro de listas em cada linha. A ideia é que a matriz fosse apresentada em um formato onde cada elemento está em uma posição, como na tabela abaixo.

|   |   |   |
|---|---|---|
| 1 | 2 | 3 |
| 4 | 5 | 6 |

Para estes casos é necessário o uso de uma outra estrutura de dados, o DataFrame, tratado no subtópico seguinte.

### DataFrames

Agora que você já conhece como as `Series` funcionam, vamos apresentar a você o `DataFrame`, que difere das `Series` por serem multidimensionais, ou seja, aqui temos uma estrutura que trabalha com linhas e colunas (Podemos dizer também que temos matrizes aqui) `r emo::ji("rainbow")`.

Boa parte dos métodos disponíveis em uma `Series` também são aplicáveis em `DataFrames`, o que ajuda no aprendizado de utilização da API do Pandas, mas é importante entender que, em diversos casos o simples fato de haver mais dimensões nos dados torna a manipulação diferente, com resultados diferentes (Isto para os mesmos métodos).

Vejamos algumas características bacanas dos `DataFrames`

```{python}
matriz = pd.DataFrame([[1, 2, 3], [4, 5, 6]])
print(matriz)
```

O mesmo processo feito acima, quando realizado nas `Series` gerou listas de listas, aqui não, tem-se uma matriz com formas de recuperação por linhas e colunas. Da mesma forma que as `Series`, os `DataFrames` tem o índice que pode ser nomeado, e além destes, as colunas, que também podem ser nomeadas e utilizadas para a recuperação de dados.

```{python}
tabela = pd.DataFrame([[.9, .8, .7], [.4, .5, .7]], columns = ['primeiro', 'segundo', 'terceiro'], index = ['zero', 'um'])
print(tabela)
```

Pode-se também utilizar os dicionários e trasforma-los em `DataFrames`, veja como isto é feito.

```{python}
dicto = {
  'nome': ['felipe', 'maria'],
  'idade': [12, 13]
}

df = pd.DataFrame(dicto); print(df)
```

Bem, agora que você entendeu a diferença fundamental entre estas estruturas de dados, vamos para a parte de manipulação delas.

### Seleção e filtro dos dados

Uma parte muito importante é a seleção e filtro dos dados, com elas basicamente faremos a manipulação dos dados.

Vamos começar fazendo a busca utilizando os índices (index) e as colunas (No caso dos `DataFrames`). Para isto, vamos utilizar os métodos `.loc`, que permitem buscar uma linha com algum nome de índice específico e o `.iloc` que busca uma linha em uma posição específica.

A sintaxe de utilização básica para as duas estruturas de dados podem ser vistas abaixos:

| DataFrame        | Series     |     
| ------------- |:-------------:|
| .loc[linha, coluna]  | .loc[linha] |
| .iloc[posição da linha, posição da coluna] | .iloc[posição da linha] |

Os métodos mudam exatamente por conta das diferenças apresentadas entre as estruturas de dados, assim, o `.loc` e o `.iloc` permitem a busca por linhas e colunas nos `DataFrames` e somente das linhas em uma `Series`. 

```{python}
df = pd.DataFrame({
  'nome': ['Joana', 'Maria', 'Josefa'],
  'idade': [15, 18, 21],
  'nota': [8, 9, 10]
}, index = [7, 8, 9])

# Recuperando a aluna com index 9
df.loc[9, 'nome']

# É possível também recuperar mais de uma coluna com o .loc
df.loc[9, ['nome', 'idade']]

# Recuperando a aluna na posição 2
df.iloc[2]['nome']

# Recuperando duas colunas
df.iloc[2][['nome', 'idade']]

# Recuperando a linha 1 (Índice 8) e coluna 1 (Idade)
df.iloc[1, 1]
```

Dentro destes métodos de busca ainda é possível passar uma expressão booleana, para realizar um filtro dos dados. Veja o exemplo abaixo, de um `DataFrame`, é desejado todas as linhas da coluna `numeros`, onde os valores sejam maiores ou iguais a 5.

```{python}
df = pd.DataFrame({'numeros': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]})

df[df['numeros'] >= 5]
```

> O exemplo acima foi apresentado com um `DataFrame`, mas também pode ser aplicado nas `Series`.

Estes são os conceitos básicos para a manipulação e filtragem dos dados, existem muitos métodos para a manipulação e filtragem, aqui ainda veremos alguns deles, mas, inicialmente estes já resolver muitos problemas das etapas de análise de dados.

### Agrupamento de dados e agregações

Muitas vezes queremos agrupar nossos dados, seja para facilitar a manipulação, o entendimento das relações dos dados, ou mesmo para aplicar funções sobre cada um dos grupos e obter informações a partir disto. Para tal pode ser usado os agrupamentos e agregações.

As agregações apresentam diversas derivações de definição, aqui foi assumido que "Agregações são operações aplicadas sobre os dados que resultam em um conjunto de valores". 

No Pandas, o retorno de uma agregação pode mudar de acordo com a estrutura de dados onde a operação é aplicada, no caso das `Series` é retornado apenas um valor escalar. Para os `DataFrames`, um valor para cada linha/coluna é retornado.

Algumas operações de agregação são:

- sum() -> Realiza somatório;
- min() -> Busca o valor mínimo;
- max() -> Busca o valor máximo;
- count() -> Realiza a contagem de elementos.

```{python}
s = pd.Series([1, 2, 3])
df = pd.DataFrame([[1, 2, 3,], [4, 5, 6]])

# Agregando Series
print(s.sum())
# Agregando DataFrame
print(df.sum())
```

Já o agrupamento representa a divisão dos dados em conjuntos que possuem alguma similaridade, no Pandas o agrupamento é realizado com o método `groupby` presente nas classes `Series` e `DataFrames`.

> O critério de similaridade citado anteriormente é definido pelo usuário

Aqui vamos focar no agrupamento dos `DataFrames`, mas os passos são os mesmos para as `Series`.

```{python}
df = pd.DataFrame({
  'nome': ['Tel1', 'Tel2', 'Tel3'],
  'tipo': ['antigo', 'novo', 'novo']
})

# Etapa de divisão dos dados
agrupado = df.groupby('tipo')
```

No exemplo acima, os dados foram agrupados de acordo com a coluna `tipo`, colocando no mesmo grupo linhas que possuam o registro da coluna `tipo` igual.

Certo, a operação é simples e intuitiva, mas o que devemos esperar deste método ? Intuitivamente pensamos em um conjunto de `DataFrames`, cada um representando um grupo e é exatamente isto que o Pandas retorna, porém há algumas particularidades.

O tipo retornado de um `groupby` deixa de ser um `DataFrame` e passa a ser um `DataFrameGroupBy`, que facilita a manipulação dos grupos com métodos especializados.

Vamos iniciar o entendimento do `DataFrameGroupBy` pela verificação dos grupos criados, este processo que é feito através do acesso ao método `groups`.

```{python}
print(agrupado.groups)
```

Acessando o atributo `groups` é possível verificar todos os grupos gerados e seus membros. Além disto, com um objeto `DataFrameGroupBy` é possível aplicarmos os conceitos de agregação dentro dos grupos que foram gerados através do `groupby`.

Para entendermos o funcionamento do processo de agrupamento e agregação juntos, vejamos a definição feita pelo `Hadley Wickham`, que faz a separação de cada processo nas etapas `Dividir-Aplicar-Combinar`

![](images/03.08-split-apply-combine.png)

O processo de dividir é o agrupamento, onde os dados são agrupados de acordo com alguma característica definida previamente, a aplicação realiza as agregações, filtros ou transformações e por fim a combinação, que representa a junção dos resultados das etapas anteriores.

Para que se haja um entendimento melhor, vamos criar um exemplo.

```{python}
df = pd.DataFrame({
  'nome': ['felipe', 'joão', 'maria', 'ana'],
  'idade': [19, 19, 20, 20],
  'dinheiro': [100, 100, 150, 150]
})
```

Vamos agrupar estes dados, levando em consideração a idade.

```{python}
# Esta é a etapa de divir, da definição do Hedley
agrupado = df.groupby('idade')

# Aplicando uma agregação
## Esta é a etapa de aplicação e junçaõ, definida pelo Hedley
print(agrupado.count())
```

Veja que o agrupamento e a contagem foram realizados. E se for necessário aplicar a agregação em uma coluna específica ? É possível!

```{python}
# Agregando somente o dinheiro de cada grupo
print(agrupado['dinheiro'].sum())
```

Pronto! Com estes métodos de manipulação já é possível resolver diversos problemas do mundo real!

### Funções de leitura e escrita de dados

Além das estruturas de dados poderosas, o pandas também possui funções para leitura e escrita de dados que facilitam muito a vida `r emo::ji("rocket")`.

Como existem muitas funções para leitura e escrita, aqui serão apresentadas apenas algumas, mas não deixe de conferir a [documentação do projeto](https://pandas.pydata.org/pandas-docs/stable/) para conhecer as demais funções oferecidas.

Caso você esteja trabalhando com dados estruturados, salvos em um arquivo csv, existe a função `read_csv` para te ajudar.

```{python}
df = pd.read_csv('data/titanic.csv') # O caminho pode ser diferente eu sua máquina
```

O ponto importante a ser notado é que, os dados quando carregados com as funções do pandas, sempre serão devolvidos em `Series` ou `DataFrames`. Vejamos o tipo do dado carregado

```{python}
type(df)
```

Um `DataFrame`, o que possibilita a aplicação de todos os métodos já vistos aqui. Vamos ver o conteúdo carregado através dos métodos `head` e `tail`, que recuperar o início e o final do `DataFrame`, respectivamente.

```{python}
print(df.head()) # Função que mostra o início do DataFrame carregado

print(df.tail()) # Função que mostra o final do DataFrame carregado
```

Caso os dados que você está trabalhando sejam oriundos de algum `web serviço`, o pandas também pode te ajudar! Com o método `read_json` você pode passar não só o nome do arquivo json em sua máquina, mas também a URL do `web serviço` que distribui tais dados. Vamos recuperar dados de um `web serviço` de exemplo.

```{python}
json_frame = pd.read_json('http://dummy.restapiexample.com/api/v1/employees')

print(json_frame.head())
print(json_frame.columns) # Recupera as colunas do DataFrame
```

Da mesma forma que a leitura, fazer escrita de dados com pandas é muito simples, tendo os dados em `Series` ou `DataFrame` é possível salvar os dados em diferentes formatos. Por exemplo, para salvar uma `Serie` ou um `DataFrame` em um arquivo CSV o método `to_csv` pode ser utilizado.

Mas caso você queira salvar em um arquivo json, basta trocar o método `to_csv` para `to_json` e pronto! Seus dados já estarão disponibilizados no sistema de arquivo nos formados indicados.

```{python}
df.to_csv('nome_do_csv.csv') # Salva o CSV
df.to_json('nome_do_json.json') # Salva o JSON
```

Viu ? É tudo muito simples e direto, o que te permite focar em sua análise e deixar de lado problemas com sintaxe `r emo::ji("statue_of_liberty")`. Para fechar esta introdução a análise de dados, vamos ver um pouco sobre visualização de dados, que facilita e potencializa a análise de dados. 

## Para saber mais

Não deixe de buscar mais informações! Abaixo alguns links que podem ser úteis.

- [Python Data Science Handbook](http://shop.oreilly.com/product/0636920034919.do)
- [Documentação - Pandas](https://pandas.pydata.org/pandas-docs/stable/)