# Introdução ao Python `r emo::ji("rocket")`

Python é uma linguagem multiparadigma, com uma sintaxe muito simples que permite ao utilizador focar no problema e deixar de lado qualquer tipo de especificidade. Vem sendo amplamente utilizada em diversas áreas, principalmente, por cona das milhares de bibliotecas que possui, todas elas distribuídas pela comunidade incrível que a linguagem possui `r emo::ji("heart")`

Nesta introdução, o foco será a aplicação da linguagem Python na manipulação e tratamento de dados, utilizando como base a biblioteca Pandas.

Você pode estar se perguntando o motivo da utilização desta biblioteca e a resposta é bem simples, Python é uma linguagem para uso geral, assim, suas funções nativas não tem foco em uma aplicação específica, como acontece em linguagens como R e Julia, que possuem áreas específicas de aplicação, assim não podemos esperar que, nativamente a linguagem tenha métodos variados para a manipulação e tratamento de dados e é nesta parte que o pandas entra, facilitando toda manipulação e tratamento de dados com funções incríveis.

Vamos começar !

## Introdução ao Pandas `r emo::ji("panda_face")`

Como forma de iniciar, vamos começar entendendo o que é a biblioteca Pandas e qual seu objetivo geral, para isto, vejamos a definição feita na documentação oficial do projeto.

> Pandas é uma biblioteca open source, licenciada pelo BSD, que fornece estruturas de dados de alto desempenho e fáceis de usar e ferramentas de análise de dados para a linguagem de programação Python.

Veja então que, tudo o que é necessário para a realização da maioria dos casos de análise de dados utilizando a linguagem Python, irão, bem provavelmente, trabalhar com esta biblioteca.

Para que se tenha uma ideia, o pandas pode ser aplicado em análises envolvendo:

- Finanças;
- Geociências;
- Ciência social;
- Além de diversas outras áreas de ciências e engenharia.

Isto tudo por contar com diversas funções e estruturas de dados que facilitam os processos de análise, essas discutidas nos próximos tópicos. 

## Estruturas de dados

O Pandas disponibiliza diversas estruturas de dados, sendo as principais:

- Series;
- DataFrames.

Nos subtópicos abaixo vamos ver as características de cada uma destas estruturas, e em seguida, veremos alguns utilitários para leitura dos dados com Pandas.

### Series

As `Series` são estruturas de dados unidimensionais, que contam com diversos métodos para a manipulação de dados.
Pode-se entender que as `Series` são estruturas de dados simples, assim como as listas padrões da linguagem Python, com uma pequena diferença, para cada item dentro de uma `Series` tem-se índices, em formatos de texto ou numéricos.

Vamos começar a utilização, para facilitar o entendimento.

```{r, echo=FALSE}
# Estes comandos não devem ser executados em seu terminal
library(reticulate) 
use_python("venv/bin/python3")
```

Para iniciar, vamos importar a biblioteca pandas com o 'apelido' de `pd`, em seguida, vamos criar uma `Series` simples, passando como parâmetro de entrada uma lista com três valores, veja:

```{python}
import pandas as pd

s = pd.Series([1, 2, 3]); print(s)
```

É interessante notar o índice na `Series` (Lateral esquerda), citado anteriormente, que permitem uma recuperação rápida e simples, sendo muito parecidas com a recuperação de valores em um dicionário em Python, a diferença aqui é que, estas estruturas de dados são criadas para trabalhar com grandes conjuntos de dados, sem contar nas facilidades de manipulação dos dados.

```{python}
print(s[0]) # Recupera o valor do índice com nome 0
```

Para visualizar somente o índice, utilizamos o atributo `index`.

```{python}
print(s.index)
```

Este também pode ser facilemente editado.

```{python}
s.index = ["um", "dois", "tres"]

print(s.index)
```

Também é possível já criar uma `Series` com um índice personalizado, para isto, basta passar no construtor, uma lista representado o índice antes dos dados, veja:

```{python}
s = pd.Series([7, 8, 9], [1, 2, 3])

# ou
# s = pd.Series([7, 8, 9], index=[1, 2, 3]) # Fica explicito quem é o índice
```

Veja que a primeira lista passada representa o índice, e a segunda os dados.

```{python}
print(s)
```

É possível também, transformar facilmente os dicionários em `Series`. 

```{python}
dicto = {
  'faculdade': 'Fatec',
  'nota': 10 
}

dicto_s = pd.Series(dicto); print(dicto_s)
```

Após a conversão, o uso é basicamente o mesmo do dicionário, porém com os benefícios já citados. Além do que já foi dito sobre os `Series`, é importante lembrar que, estas estruturas de dados possuem diversos métodos para facilitar a manipulação e entendimento dos dados, vamos a alguns destes métodos.

Porém, como citado lá no início deste tutorial, as `Series` são estruturas unidimensionais, o que significa que todo o trabalho com estas estruturas é feito utilizando apenas como base as linhas, não sendo possível a utilização através de colunas. Como exemplo, vamos tentar inserir uma matriz de dados dentro de uma `Series`, veja que é possível, mas, tudo será tratado como listas de listas, de forma separada.

```{python}
matriz = pd.Series([[1, 2, 3], [4, 5, 6]])
print(matriz)
```

Percebeu ? Não há uma matriz, e sim várias listas dentro de listas em cada linha. Para estes casos é necessário o uso de uma outra estrutura de dados, o DataFrame, tratado no subtópico seguinte.

### Dataframes

Agora que você já conhece como as `Series` funcionam, vamos apresentar a você o `DataFrame`, que difere das `Series` por serem multidimensionais, ou seja, aqui temos uma estrutura que trabalhará com linhas e colunas (Podemos dizer também que temos matrizes aqui) `r emo::ji("rainbow")`.

Boa parte dos métodos disponíveis em uma `Series` também é aplicável em `DataFrames`, o que ajuda no aprendizado de utilização da API do pandas, mas é importante entender que, em diversos casos o simples fato de haver mais dimensões nos dados torna a manipulação diferente, com resultados diferentes (Isto para os mesmos métodos), sem contar que o armazenamento também pode diferir.

Vejamos algumas características bacanas dos `DataFrames`

```{python}
matriz = pd.DataFrame([[1, 2, 3], [4, 5, 6]])
print(matriz)
```

O mesmo processo feito acima, quando realizado nas `Series` gerou listas de listas, aqui não, tem-se uma matriz com formas de recuperação por linhas e colunas. Da mesma forma que as `Series`, os `DataFrames` tem o índice que pode ser nomeado, e além destes, as colunas, que também podem ser nomeadas e utilizadas para a recuperação de dados.

```{python}
tabela = pd.DataFrame([[.9, .8, .7], [.4, .5, .7]], columns = ['primeiro', 'segundo', 'terceiro'], index = ['zero', 'um'])
print(tabela)
```

Pode-se também utilizar os dicionários e trasforma-los em `DataFrames`, veja como isto é feito.

```{python}
dicto = {
  'nome': ['felipe', 'maria'],
  'idade': [12, 13]
}

df = pd.DataFrame(dicto); print(df)
```

Bem, agora que você entendeu a diferença fundamental entre estas estruturas de dados, vamos para a parte de manipulação delas.

### Seleção e filtro dos dados

Uma parte muito importante é a seleção e filtro dos dados, com elas basicamente faremos a manipulação dos dados.

Vamos começar fazendo a busca utilizando os índices (index) e as colunas (No caso dos `DataFrames`). Para isto, vamos utilizar os métodos `.loc`, que permitem buscar uma linha com algum nome de índice específico e o `.iloc` que busca uma linha em uma posição específica.

A sintaxe de utilização básica para as duas estruturas de dados podem ser vistas abaixos:

| DataFrame        | Series     |     
| ------------- |:-------------:|
| .loc[linha, coluna]  | .loc[linha] |
| .iloc[linha] | .iloc[linha] |

No caso do `.loc` a sintaxe muda exatamente pelas diferenças apresentadas entre o `Series` e o `DataFrame`. Para o caso do `.iloc` ele busca somente a posição da linha, nas duas estruturas.

```{python}
df = pd.DataFrame({
  'nome': ['Joana', 'Maria', 'Josefa'],
  'idade': [15, 18, 21],
  'nota': [8, 9, 10]
}, index = [7, 8, 9])

# Recuperando a aluna com index 9
df.loc[9, 'nome']

# É possível também recuperar mais de uma coluna com o .loc
df.loc[9, ['nome', 'idade']]

# Recuperando a aluna na posição 2
df.iloc[2]['nome']

# Recuperando duas colunas
df.iloc[2][['nome', 'idade']]
```

Dentro destes métodos de busca ainda é possível passar uma expressão booleana, para realizar um filtro dos dados.

```{python}
df = pd.DataFrame({'coluna': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]})

df[df['coluna'] >= 5]
```

E isto também vale para as `Series`, utilizando a mesma estrutura. Bem, este é o básico para a manipulação e filtragem dos dados, existem muitos métodos para a manipulação e filtragem, aqui ainda veremos alguns deles, mas, inicialmente estes já resolver muitos problemas das etapas de análise de dados.

### Agrupamento de dados e agregações

Muitas vezes queremos agrupar nossos dados, seja para facilitar a manipulação, o entendimento das relações dos dados, ou mesmo para aplicar funções sobre cada um dos grupos e obter informações a partir disto. Para isto utilizamos os agrupamentos e agregações.

As agregações apresentam diversas derivações de definição, a utiliza aqui será a que, são operações aplicadas sobre os dados que resultam em um conjunto de valores, ou mesmo um valor escalar. Entenda que, o retorno pode mudar de acordo com a estrutura de dados onde se aplica a agregação, no caso das `Series` será retornado apenas um valor e no caso dos `DataFrames` um valor para cada linha/coluna (Variando com a definição do usuário) é retornado.

Algumas operações de agregação são:

- sum() -> Realiza somatório;
- min() -> Busca o valor mínimo;
- max() -> Busca o valor máximo;
- count() -> Realiza a contagem de elementos.

```{python}
s = pd.Series([1, 2, 3])
df = pd.DataFrame([[1, 2, 3,], [4, 5, 6]])

# Agregando Series
print(s.sum())
# Agredando DataFrame
print(df.sum())
```

Já o agrupamento representa a divisão dos dados, em conjuntos que possuem alguma similaridade (O critério de similaridade é definido pelo usuário), no pandas o agrupamento é realizado com o método `groupby` presente nas classes `Series` e `DataFrames`.

Aqui vamos focar no agrupamento das `Series`.

```{python}
df = pd.DataFrame({
  'nome': ['Tel1', 'Tel2', 'Tel3'],
  'tipo': ['antigo', 'novo', 'novo']
})

# Etapa de divisão dos dados
agrupado = df.groupby('tipo')
```

No exemplo acima, os dados foram agrupados de acordo com a coluna `tipo`. O que é esperado como retorno do método `groupby` ? Intuitivamente pensamos em um conjunto de `DataFrames`, cada um representando um grupo e é exatamente isto que o Pandas retorna, porém há algumas particularidades.

O tipo retornado de um `groupby` deixa de ser um `DataFrame` e passa a ser um `DataFrameGroupBy` que possibilita e facilita a manipulação dos grupos.

Caso você queira ver os grupos gerados, use o atributo `groups` no objeto gerado com o `groupby`.

```{python}
print(agrupado.groups)
```

Bem, ao juntarmos os conceitos de agregação e agrupamento, temos um processo que pode ser um problema de ser entendido, para isto, vamos utilizar a definição feita por Hadley Wickham, onde ele simplesmente separa todo o processo em etapas, sendo estas: `Dividir-Aplicar-Combinar`.

![](images/03.08-split-apply-combine.png)

O processo de dividir é o agrupamento, onde os dados são agrupados de acordo com alguma característica definida previamente, a aplicação realiza as agregações, filtros ou transformações e por fim a combinação, que representa a junção dos resultados das etapas anteriores.

Para que se haja um entendimento melhor, vamos criar um exemplo.

```{python}
df = pd.DataFrame({
  'nome': ['felipe', 'joão', 'maria', 'ana'],
  'idade': [19, 19, 20, 20],
  'dinheiro': [100, 100, 150, 150]
})
```

Vamos agrupar estes dados, levando em consideração a idade.

```{python}
# Esta é a etapa de divir, da definição do Hedley
agrupado = df.groupby('idade')

# Aplicando uma agregação
## Esta é a etapa de aplicação e junçaõ, definida pelo Hedley
print(agrupado.count())
```

Veja que o agrupamento e a contagem foi realizado, mas caso eu queira aplicar uma agregação em uma coluna especifica ? Você pode!

```{python}
# Agregando somente o dinheiro de cada grupo
print(agrupado['dinheiro'].sum())
```

### Funções de leitura e escrita de dados

Além das estruturas de dados poderosas, o pandas também possui funções para leitura e escrita de dados que facilitam muito a vida `r emo::ji("rocket")`.

Existem diversas funções de leitura, aqui serão apresentadas apenas algumas, mas não deixe de conferir a documentação do projeto para entender melhor as funções de leitura e escrita de dados.

Para a leitura de dados no formato csv, podemos utilizar a função `read_csv`.

```{python}
df = pd.read_csv('data/titanic.csv') # O caminho pode ser diferente eu sua máquina

print(df.head()) # Função que mostra o início do DataFrame carregado
print(df.tail()) # Função que mostra o final do DataFrame carregado
```

Caso os dados que você está coletando sejam oriundos de alguma API Rest o pandas também pode te ajudar! Com o método `read_json` você pode passar não só o nome do arquivo json em sua máquina, mas também a URL da API que distribui tais dados. Ao fazer isto, o pandas trata de já transformar os dados na estrutura adequada, podendo ser uma `Series` ou `DataFrame`, veja como a utilização é simples.

```{python}
json_frame = pd.read_json('http://dummy.restapiexample.com/api/v1/employees')

print(json_frame.head())
print(json_frame.columns) # Recupera as colunas do DataFrame
```

Da mesma forma que a leitura, fazer escrita de dados com pandas é muito simples, tendo os dados em `Series` ou `DataFrame` é possível salvar os dados em diferentes formatos. Por exemplo, para salvar uma `Serie` ou um `DataFrame` em um arquivo CSV o método `to_csv` pode ser utilizado.

Mas caso você queira salvar em um arquivo json, basta trocar o método `to_csv` para `to_json` e pronto! Seus dados já estarão disponibilizados no sistema de arquivo nos formados indicados.

```{python}
df.to_csv('nome_do_csv.csv') # Salva o CSV
df.to_json('nome_do_json.json') # Salva o JSON
```

Viu ? É tudo muito simples e direto, o que te permite focar em sua análise e deixar de lado problemas com sintaxe `r emo::ji("statue_of_liberty")`. Para fechar esta introdução a análise de dados, vamos ver um pouco sobre visualização de dados, que facilita e potencializa a análise de dados. 

## Para saber mais

Não deixe de buscar mais informações! Abaixo alguns links que podem ser úteis.

- [Python Data Science Handbook](http://shop.oreilly.com/product/0636920034919.do)
- [Documentação - Pandas](https://pandas.pydata.org/pandas-docs/stable/)