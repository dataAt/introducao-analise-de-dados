[
["introdu√ß√£o.html", "1 Introdu√ß√£o 1.1 Dados 1.2 O que √© an√°lise de dados? 1.3 Contribui√ß√£o", " 1 Introdu√ß√£o A an√°lise de dados √© uma das atividades mais interessantes da atualidade, com ela √© poss√≠vel monitorar o governo (por exemplo, Opera√ß√£o serenata), fazer empresas de sucesso e produtos que atendam a real necessidade de seus clientes, e o mais importante, comprovar a veracidade de informa√ß√µes recebida e saciar nossa curiosidade. Isto porque, com a quantidade de dados dispon√≠veis, podemos literalmente, saber sobre tudo, aplicando t√©cnicas de an√°lise de dados. Portanto, este minicurso tem como objetivo apresentar, de forma introdut√≥ria, as principais tecnologias para analisar dados a partir das linguagens de programa√ß√£o R e Python. 1.1 Dados Muito √© dito sobre dados, que estes s√£o abundantes e que est√£o em constante crescimento, por√©m, o que s√£o dados? Bem, esta pergunta possui diversas respostas, isso porque h√° v√°rias defini√ß√µes para dados. Aqui iremos assumir que dados s√£o: ‚ÄúQualquer coisa registrada com o prop√≥sito de posterior analise‚Äù - Dr.¬†Rafael Santos. Agora que sabemos a defini√ß√£o de dados, podemos deduzir que Big Data √© um alto volume de dados. N√£o entraremos no m√©rito do que √©, ou n√£o, considerado Big Data. Caso queira ler mais sobre o assunto, recomendamos o artigo Big data: A survey publicado por Min Chen e colaboradores. 1.1.1 Tipos de dados A tabela 1.1 foi feita com base no material de estat√≠stica da UFPR e o template utilizado foi retirado do livro-texto Claus O. Wilke. Table 1.1: Tipos de vari√°veis encontradas durante um cen√°rio de an√°lise de dados Tipo de vari√°vel Exemplos Escala apropriada Descri√ß√£o Quantitativa/num√©rica cont√≠nua 1.3, 5.7, 83, 1.5x10^-2 Cont√≠nuas Valores mensur√°veis que assumem valores em um escala cont√≠nua (na reta real). Usualmente devem ser medida atrav√©s de algum instrumento. Exemplo: peso (balan√ßa), tempo (rel√≥gio), e press√£o arterial. Quantitativa/num√©rica discreta 1, 2, 3, 4 Discretas Caracter√≠sticas mensur√°veis que podem assumir apenas um n√∫mero finito ou infinito cont√°vel de valores e, assim, somente fazem sentido valores inteiros. Geralmente s√£o o resultado de contagens. Exemplos: n√∫mero de filhos, n√∫mero de bact√©rias por litro de leite, n√∫mero de cigarros fumados por dia. Quantitativa/categ√≥ricas nominais Cachorro, peixe Discreto N√£o possui ordena√ß√£o dentre as categorias. Essas vari√°veis s√£o tamb√©m chamadas de factors. Exemplo: Sexo, cor dos olhos, doente/sadio. Quantitativa/categ√≥ricas ordinais Janeiro, Fevereiro Discreto Existe uma ordena√ß√£o entre as categorias. Essas vari√°veis s√£o tamb√©m chamadas de ordered factors. Exemplo: escolaridade (1¬∞, 2¬∞, 3¬∞), m√™s de observa√ß√£o (janeiro, fevereiro‚Ä¶ dezembro). Data ou tempo Jan.¬†5 2018, 8:03am Cont√≠nuo ou Discreto Dia ou hora espec√≠ficos. Tamb√©m datas gen√©ricas. Exemplo 29 de Fevereiro em anos n√£o bissextos Texto The quick brown fox jumps over the lazy dog. Nenhum, ou discreto Texto normal e pode ser tratado como categ√≥rico se precisar. 1.1.2 Formatos de dados Como mencionado anteriormente, existem muitos dados dispon√≠veis providos das mais diversas fontes e formatos. Boa parte dos desafios na an√°lise de dados est√£o vinculados aos formatos nos quais os dados est√£o dispon√≠veis, isso porque, dependendo do formato, existem diferentes etapas de organiza√ß√£o que devem ser aplicadas. ‚ÄúOs conjuntos de dados arrumados s√£o todos iguais, mas todos os conjuntos de dados desorganizados s√£o desorganizados √† sua pr√≥pria maneira.‚Äù - Hadley Wickham Nos subt√≥picos abaixo, s√£o descritos os principais formatos de dados e exemplos de cada um. 1.1.2.1 Dados estruturados Este formato de dado segue a estrutura de linhas e colunas (retangular). S√£o geralmente encontrados em banco de dados, Excel (.xls) e valores separados por v√≠rgulas (do ingl√™s Comma-separated values) (.csv) 1.1.2.2 Dados Semiestruturados S√£o dados que possuem uma organiza√ß√£o clara, por√©m, n√£o seguem o padr√£o de linha e coluna. Geralmente s√£o aqueles formatos que recebemos em requisi√ß√µes via API (do ingl√™s &quot;Application Programming Interface) Web, por exemplo, JSON, XML e HTML. 1.1.2.3 Dados n√£o estruturados S√£o aqueles que n√£o conseguimos identificar uma organiza√ß√£o clara, geralmente, s√£o arquivos com forte teor textual, por exemplo, e-mail, tweets, PDF, imagens, v√≠deos, entre outros. Lembrando que, nem todo dado desorganizado √© n√£o estruturado. 1.2 O que √© an√°lise de dados? Segundo John W. Tukey, grande parte da an√°lise de dados √© inferencial, ou seja, o ato de extrair informa√ß√µes de uma amostra em rela√ß√£o ao conjunto todo. √â interessante ressaltar que, an√°lise de dados n√£o √© um conceito novo, a defini√ß√£o de Tukey foi publicada em 1962, no artigo The Future of Data Analysis. Infer√™ncia estat√≠stica √© um ramo da Estat√≠stica cujo objetivo √© fazer afirma√ß√µes a partir de um conjunto de valores representativos (amostra) sobre um universo (popula√ß√£o). - Wikipedia Buscando por mais defini√ß√µes, a Wikipedia descreve an√°lise de dados como o processo de observa√ß√£o, limpeza, transforma√ß√£o e modelagem de dados. Com o objetivo de extrair informa√ß√µes de dados n√£o tratados. 1.2.1 O que faz um analista de dados? O artigo ‚ÄúData Engineer, Data Analyst, Data Scientist - What‚Äôs the Difference ?‚Äù publicado pelo dataquest, define o analista de dados como um agregador para a companhia, que obt√©m respostas atrav√©s de dados. Dessa forma, ajudando na tomada de decis√£o da empresa. De acordo com o artigo do dataquest, um analista de dados √© respons√°vel pelas seguintes √°reas: Limpeza e organiza√ß√£o de dados; Uso de estat√≠stica para ter uma vis√£o geral dos dados; An√°lise de tend√™ncias encontradas nos dados; Cria√ß√£o de gr√°ficos e dashboards para ajudar na interpreta√ß√£o e tomada de decis√£o da empresa; Apresenta√ß√£o dos resultados obtidos para os clientes. Resumindo essas tarefas, o analista deve possuir habilidades de limpeza, manipula√ß√£o e visualiza√ß√£o dos dados, entender do neg√≥cio e saber transferir as informa√ß√µes geradas de suas an√°lises para diferentes tipos clientes, com ou sem dom√≠nio t√©cnico. 1.2.2 Quais s√£o as diferen√ßas entre analista e cientista de dados? Tanto se fala de analista e cientista de dados, mas afinal, qual √© a diferen√ßa?üë©‚Äçüíª Segundo a revista Harvard Business Review, cientista de dados √© considerada a profiss√£o mais sexy do s√©culo 21. De acordo com Josh Wills, um cientista de dados √© melhor em estat√≠stica do que qualquer engenheiro de software e melhor em engenharia de software do que qualquer estat√≠stico. Um cientista de dados possui todas as habilidades de um analista, mas, em ess√™ncia cont√©m um dom√≠nio maior em estat√≠stica, matem√°tica e Machine Learning. Em busca de um compilado de defini√ß√µes, formulamos nossa resposta com base nesses sites: dataquest; edureka; simplilearn; betterbuys; kdnuggets. A defini√ß√£o que escolhemos foi a do site kdnuggets: ‚ÄúO analista de dados √© como o Sherlock Holmes üîç do time de ci√™ncia de dados‚Äù. Ainda em sua defini√ß√£o, ‚Äúo analista busca resposta para o time e para o neg√≥cio. Por outro lado o cientista de dados, cria modelos estat√≠sticos de aprendizado de m√°quina, visualiza√ß√µes mais elaboradas e gera novas perguntas em rela√ß√£o aos dados‚Äù. Fiquem √† vontade para adicionar mais diferen√ßas, veja como contribuir no README do projeto. 1.2.3 Processos da an√°lise de dados Agora que sabemos o que faz um analista de dados, √© necess√°rio entender as etapas do processo de an√°lise de dados. Na Figura 1.1 √© apresentado um fluxograma sequencial das etapas do processo. Figure 1.1: Etapas do processo de an√°lise de dados - Fonte: Wickham and Grolemund (2017) A primeira etapa (Import) consiste em fazer a leitura aos dados, independentemente do formato do arquivo (.csv, .kml, .json). Ap√≥s a leitura dos dados, √© necess√°rio organizar, estruturar os dados e corrigir poss√≠veis erros tornando os dados tidy. O termo tidy refere-se a nova estrutura do conjunto de dados, onde cada coluna √© um atributo e cada linha √© uma observa√ß√£o (Wickham and Grolemund 2017). A seguir √© apresentado um exemplo sobre a linguagem R, com 3 atributos (nome, idade e escolaridade) e 3 observa√ß√µes: library(knitr) escola &lt;- tibble::tibble(nome=c(&quot;Joao&quot;, &quot;Maria&quot;,&quot;Helena&quot;), idade=c(14, 15, 21), escolaridade=c(&quot;EF&quot;, &quot;EM&quot;, &quot;Graduacao&quot; )) knitr::kable(escola) nome idade escolaridade Joao 14 EF Maria 15 EM Helena 21 Graduacao Com o dado no formato tidy, facilmente pode-se observar que Jo√£o tem 14 anos e est√° no ensino fundamental. A etapa de Transform √© composta pela adi√ß√£o de novos atributos com base no conjunto de dados prim√°rio, por exemplo, a m√©dia da idade dos alunos. Esta etapa tem como objetivo gerar questionamentos sobre o conjunto de dados e tentar respond√™-las atrav√©s da manipula√ß√£o dos dados. No c√≥digo em R abaixo √© apresentado um exemplo de transforma√ß√£o que pode ser realizada, onde um novo atributo √© gerado ao extrair o dia da smeana de uma determinada data. data &lt;- lubridate::dmy(&quot;11/10/2018&quot;) lubridate::wday(data, label = TRUE) ## [1] qui ## Levels: dom &lt; seg &lt; ter &lt; qua &lt; qui &lt; sex &lt; s√°b No exemplo acima, estamos usando o pacote lubridate para descobrir o dia da semana da data 11 de outubro de 2018. A etapa Visualise consiste em produzir representa√ß√µes dos dados que permitam uma an√°lise visual das informa√ß√µes, como por exemplo, a utiliza√ß√£o de gr√°ficos. Visualizar o conjunto de dados, pode gerar novos conhecimentos, questionamentos e respostas. Segundo Wilke (2019), a visualiza√ß√£o de dados, √© a parte arte e a parte ci√™ncia na √°rea de ci√™ncia de dados, portanto, a visualiza√ß√£o precisa estar correta e agrad√°vel para interpret√°-la. TIL: visualisation ou visualization possuem o mesmo significado, mas, na Europa √© com ‚Äús‚Äù e na Am√©rica com ‚Äúz‚Äù. Na etapa Models s√£o geradas abstra√ß√µes ou modelos a partir da visualiza√ß√£o Segundo Wickham and Grolemund (2017), Models s√£o ferramentas complementares de visualiza√ß√£o. Para Schutt and O≈Éeil (2013), realizar a an√°lise explorat√≥ria de dados (EDA) √© a etapa fundamental para a cria√ß√£o de um modelo. Communicate √© a √∫ltima etapa do processo, sendo fundamental para o analista transmitir as informa√ß√µes obtidas atrav√©s da an√°lise dos dados, para clientes t√©cnicos e n√£o t√©cnicos. Para isso, o analista apoia-se nos gr√°ficos e modelos criados, por isso, √© necess√°rio que os gr√°ficos possuam, pelo menos, uma est√©tica agrav√©l e de f√°cil interpreta√ß√£o. Nos pr√≥ximos cap√≠tulos √© apresentado com detalhes quais pacotes e bibliotecas podem ser aplicados em cada etapa do processo de an√°lise de dados. 1.3 Contribui√ß√£o Este material est√° em constante mudan√ßa e todas as recomenda√ß√µes e melhorias s√£o bem-vindas. Fique √† vontade para adicionar mais conte√∫do, instru√ß√µes de colabora√ß√£o no README. "],
["introdu√ß√£o-ao-r.html", "2 Introdu√ß√£o ao R 2.1 Defini√ß√£o de vari√°veis 2.2 Opera√ß√µes B√°sicas 2.3 Estruturas de decis√£o 2.4 Itera√ß√£o 2.5 Manipula√ß√£o de dados 2.6 Exemplos 2.7 Para saber mais", " 2 Introdu√ß√£o ao R R √© uma linguagem de programa√ß√£o de alto n√≠vel voltada para visualiza√ß√£o e an√°lise de dados. Em ess√™ncia foi inspirada na linguagem de programa√ß√£o S (do ingl√™s stats). Foi inicialmente escrita por Ross Ihaka e Robert Gentleman no departamento de estat√≠stica da universidade de Auckland na Nova Zel√¢ndia. Atualmente a linguagem √© mantida pelo grupo R Core Team composto por pessoas do mundo inteiro que tentam melhorar a linguagem dia ap√≥s dia. Esse conte√∫do foi baseado no livro THE R BOOK escrito por Crawley (2012), sendo considerado a b√≠blia do R. O kernel do R e os pacotes podem ser baixados pelo CRAN - Comprehensive R Archive Network. Abaixo √© apresentada a sintaxe para instalar pacotes em R: # Via CRAN install.packages(&quot;nome_do_pacote&quot;) # Via github (Pacote remotes) remotes::install_github(&quot;nome_do_repositorio/nome_do_pacote&quot;) O objetivo deste cap√≠tulo √© abordar conceitos b√°sicos do R. Caso existam informa√ß√µes que voc√™ acha relevante estar aqui, sinta-se √† vontade para contribuir. 2.1 Defini√ß√£o de vari√°veis Para atribuir um valor √† uma vari√°vel usamos o s√≠mbolo &lt;- ou =. No caso da seta, o s√≠mbolo deve apontar no sentido da vari√°vel e n√£o do valor. Segundo Wickham and Grolemund (2017), √© uma boa pr√°tica de programa√ß√£o utilizar a seta &lt;- ao inv√©s do =. A seguir √© apresentado um trecho de c√≥digo de como pode ser realizada a declara√ß√£o e atribui√ß√£o de valores na linguagem R: a &lt;- &quot;Ol√°!&quot; b &lt;- 42 22 -&gt; c 2.1.1 Tipos primitivos Agora que sabemos atribuir valores a uma vari√°vel, vamos falar sobre os tipos primitivos do R. Segundo a hierarquia do R, todo valor num√©rico √© uma inst√¢ncia da classe pai: numeric. Basicamente, o tipo double (classe filha de numeric) √© atribu√≠do √† todo n√∫mero declarado sem sufixo. No entanto, ao se definir um sufixo, outras tipagens podem ser atribu√≠das √†s vari√°veis. Como por exemplo, o tipo integer: atrav√©s da adi√ß√£o do sufixo L ao valor da vari√°vel e o tipo complex: atrav√©s do sufixo i. Outros tipos primitivos s√£o: os valores booleanos TRUE e FALSE(inst√¢ncias da classe logical) e os caracteres (inst√¢ncias da classe character) Exemplo de declara√ß√£o dos tipos primitivos # Inteiro a &lt;- 7L # Double b = 14.01 # Booleano k &lt;- FALSE # Complexo g &lt;- 12i # Caractere couse &lt;- &#39;cool&#39; # Para inspecionar o valor das vari√°veis b ## [1] 14.01 # Para verificar a classe class(a) ## [1] &quot;integer&quot; # Para ver o tipo typeof(b) ## [1] &quot;double&quot; # Para remov√™-las rm(a) Se quiser saber mais sobre o tipo complex, consulte a subse√ß√£o Para saber mais. 2.1.2 Tipos de dados estruturados Agora que conhecemos os tipos primitivos, vamos aprender sobre vetores e matrizes. Apenas relembrando, podemos dizer que vetores s√£o estruturas unidimensionais que seguem um sentido, contendo 1 linha e N colunas ou 1 coluna e N linhas. Por outro lado, a matriz √© um vetor com N-dimens√µes sendo sua representa√ß√£o b√°sica um vetor bidimensional composto por linhas e colunas. Na Figura 2.1 √© apresentado um exemplo das estruturas mencionadas. Figure 2.1: Estrutura de dados: Vetor e Matriz No R h√° dois tipos de vetores: Vetores at√¥micos: Compostos por qualquer tipo primitivo e tamb√©m do tipo chamado raw. Listas: S√£o vetores recursivos que podem ser compostos por outras listas. Colocando de maneira simples, vetores at√¥micos s√£o homog√™neos, ou seja, apenas aceitam um tipo. Se alocado mais de um tipo no vetor, √© convertido pelo tipo mais forte. A hierarquia de tipos no R √© apresentada na Figura 2.2. Figure 2.2: Hierarquia de dados - Fonte: Wickham and Grolemund (2017) A Figura 2.2 deve ser interpretada de baixo para cima. Seguindo esta ordem: character complex numeric double logical Para declarar um vetor em R usa-se c(), desta forma: # Vetor l√≥gico vetor_boleano &lt;- c(FALSE, TRUE, TRUE, FALSE) # Vetor n√∫merico vetor_numerico &lt;- c(3.14, 6.28, 2.3) # Vetor de caractere vetor_char &lt;- c(&quot;ola&quot;, &quot;pessoal&quot;, &quot;!&quot;) A convers√£o de tipos √© apresentada na c√©lula abaixo: # Esse √© um vetor misturado vetor_misturado &lt;- c(&quot;teste&quot;, FALSE, 21) # Visualiza√ß√£o dos valores atribu√≠dos vetor_misturado ## [1] &quot;teste&quot; &quot;FALSE&quot; &quot;21&quot; Ent√£o, segundo a ideia de hierarquia de tipos do R, o vetor da c√©lula acima ser√° convertido para o tipo charactere continuar√° sendo at√¥mico ü•Å. # Para verificar se √© at√¥mico is.atomic(vetor_misturado) ## [1] TRUE Por outro lado, as listas aceitam diversos tipos, sendo organizadas em listas de listas, por isso, s√£o chamadas de vetores recursivos. Podemos implementar uma lista atrav√©s do comando list(), deste modo: # Lista de boleanos lista_boleano &lt;- list(FALSE, TRUE, TRUE, FALSE) # Lista de inteiros lista_inteiro &lt;- list(12L, 10L, 7L) Podemos criar uma lista de diversos tipos, da seguinte maneira: # Lista com todos os tipos lista_misturada &lt;- list(FALSE, 12L, &#39;t&#39;, 2i) # Visualiza√ß√£o da lista lista_misturada ## [[1]] ## [1] FALSE ## ## [[2]] ## [1] 12 ## ## [[3]] ## [1] &quot;t&quot; ## ## [[4]] ## [1] 0+2i Para verificar se a lista √© at√¥mica utiliza-se o comando is.atomic(). Abaixo √© apresentado a utiliza√ß√£o do comando no vetor criado anteriormente: # S√©ra ela at√¥mica? is.atomic(lista_misturada) ## [1] FALSE A seguir √© apresentado um exemplo com uma lista n√£o at√¥mica, ou seja, uma lista heterog√™nea composta de v√°rios tipos. Mas, ser√° ela uma lista mesmo ? üßõüèø‚Äç‚ôÇÔ∏è # Verificar se √© uma lista is.list(lista_boleano) ## [1] TRUE Podemos checar o tamanhos dos nossos vetores usando a fun√ß√£o length(). J√° sabemos dos tipos de vetores, agora vamos para as matrizes. As matrizes seguem a mesma ideia dos vetores at√¥micos. Podemos implement√°-la usando o comando matrix(), deste modo: library(knitr) # Minha matriz com n√∫meros inteiros com caractere matriz &lt;- matrix(data = c(1:25, rep(&quot;teste&quot;, 5)), nrow = 5, ncol=6) # Para visualizar a matriz knitr::kable(matriz) 1 6 11 16 21 teste 2 7 12 17 22 teste 3 8 13 18 23 teste 4 9 14 19 24 teste 5 10 15 20 25 teste Ent√£o, de acordo com a hierarquia de tipos, a nossa matriz ser√° convertida para character. Podemos verificar seu tipo, desta forma: # Para verificar se √© matriz is.matrix(matriz) ## [1] TRUE # Para consultarmos por index matriz[1,4] ## [1] &quot;16&quot; Podemos acessar os valores atrav√©s dos √≠ndices de linha e coluna matriz[linha, coluna]. 2.1.3 Data Frame Um Data Frame pode ser entendido como uma matriz (Figura 2.1) composta por linhas e colunas, cujas colunas representam as vari√°veis (atributos) e as linhas representam observa√ß√µes. A Figura 2.3 apresenta um Data frame onde √© poss√≠vel observar as defini√ß√µes mencionadas anteriormente. A partir da imagem podemos inferir que o aluno Jos√© obteve 7 na disciplina de √Ålgebra Linear. Figure 2.3: Representa√ß√£o de um Data frame - Fonte: GeeksforGeeks (2018) O trecho de c√≥digo a seguir apresenta a implementa√ß√£o do Data frame apresentado na Figura 2.3. # Importa√ß√£o do pacote library(tibble) # Cria√ß√£o do tibble df_escola &lt;- tibble::tibble(Aluno = c(&quot;Jos√©&quot;, &quot;Maria&quot;, &quot;Ana&quot;, &quot;Carlos&quot;), `√Ålgebra Linear` = c(7, 10, 8, 7), `C√°lculo I` = c(8, 9, 10, 5), `Eng. Software` = c(10, 9, 5, 9), `PAD` = c(5, 7, 4, 9)) # Visualiza√ß√£o dos dados df_escola ## # A tibble: 4 x 5 ## Aluno `√Ålgebra Linear` `C√°lculo I` `Eng. Software` PAD ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Jos√© 7 8 10 5 ## 2 Maria 10 9 9 7 ## 3 Ana 8 10 5 4 ## 4 Carlos 7 5 9 9 Neste minicurso, vamos usar o pacote tibble no lugar do m√©todo data.frame contido no base do R. Dado que o tibble possui diversas vantagens em rela√ß√£o ao tradicional data.frame. Por exemplo, no tibble criado anteriormente √© poss√≠vel observar os tipos de cada atributo. Como o pacote tibble n√£o faz a convers√£o de atributos do tipo character para factor de forma autom√°tica, a etapa de an√°lise de dados se torna mais simples. Agora que sabemos a defini√ß√£o de um Data frame, vamos ler um conjunto de dados em .csv e observar algumas caracter√≠sticas: # Importa√ß√£o do pacote readr library(readr) # Lendo nosso conjunto de dados iris &lt;- readr::read_csv(file = &quot;./data/iris.csv&quot;,) # Verificando a classe dos nossos dados class(iris) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # Verificando o tipo dos nossos dados typeof(iris) ## [1] &quot;list&quot; Podemos usar quaisquer dos m√©todos apresentados anteriormente para manipular e obter informa√ß√µes do data.frame no tibble. O c√≥digo acima mostra que o tibble criado possui tr√™s classes: tbl_df, tbl e data.frame. √â poss√≠vel observar que o tibble possui como classe comum o data.frame. Podemos tirar algumas conclus√µes, a primeira √© que, existe uma classe chamada data.frame do tipo list. A segunda √© que, a lista em R √© heterog√™nea, portanto, nosso Data frame pode conter v√°rios tipos. Para verificar se a classe data.frame √© at√¥mica, retomamos a fun√ß√£o is.atomic(): # Verificando se √© atomico nosso df is.atomic(iris) ## [1] FALSE Podemos acessar os atributos de um Data Frame de diversos modos, sendo um deles, utilizando o s√≠mbolo $: # Para verificar as primeiras linhas head(iris$Species) ## [1] &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; Vamos criar mais Data Frame para fixar o aprendizado: # Cria√ß√£o do Data Frame data_frame &lt;- tibble::tibble( Risco=c(FALSE,FALSE, FALSE, FALSE,TRUE), Animal=c(&quot;Cachorro&quot;, &quot;Gato&quot;, &quot;Capivara&quot;, &quot;Girafa&quot;, &quot;Le√£o&quot;), Periculosidade=c(200, 400, 0, 7, 1000)) # Podemos acessar os valores individuais usando o &#39;$&#39; data_frame$Animal ## [1] &quot;Cachorro&quot; &quot;Gato&quot; &quot;Capivara&quot; &quot;Girafa&quot; &quot;Le√£o&quot; Risco Animal Periculosidade FALSE Cachorro 200 FALSE Gato 400 FALSE Capivara 0 2.2 Opera√ß√µes B√°sicas Agora que sabemos como declarar uma vari√°vel, um vetor e Data frame(s), nesta subse√ß√£o vamos dar algumas dicas e falar sobre alguns m√©todos estat√≠sticos. 2.2.1 Dicas √∫teis Para importar os pacotes no R usa-se o comando library(). Caso esteja com d√∫vida sobre uma determinada fun√ß√£o, use o comando ?nome_do_pacote::nome_da_funcao. # Para importar um pacote library(kohonen) # Documenta√ß√£o da fun√ß√£o som do pacote kohonen ?kohonen::som Para especificar o diret√≥rio de trabalho, usamos o comando setwd() e para verificar o diret√≥rio atual getwd(). # Para verificar seu diret√≥rio atual getwd() # Para definir um novo diret√≥rio setwd(&quot;/home/felipe/R&quot;) 2.2.2 Estat√≠stica b√°sica Nesta se√ß√£o, vamos focar em como aplicar as estat√≠sticas b√°sicas. N√£o iremos definir formalmente cada uma das fun√ß√µes estat√≠sticas abordadas, para mais informa√ß√µes consulte (http://cursos.leg.ufpr.br/ecr/). Nos exemplos a seguir iremos aplicar as seguintes fun√ß√µes estat√≠sticas: Medidas de posi√ß√£o M√©dia Mediana Medidas de dispers√£o Desvio padr√£o Para verificar o desvio padr√£o do conjunto, podemos utilizar a fun√ß√£o sd() do pacote stats (incluso por padr√£o no R). Podemos verificar a m√©dia com mean() que √© uma fun√ß√£o do pacote base (incluso por padr√£o no R) e a mediana com median() do pacote stats. Como demonstra√ß√£o, vamos utilizar o conjunto de dados do filme Star Wars: # Vamos usar o dado do filme Star Wars do pacote dplyr* suppressMessages(library(dplyr)) starwars &lt;- dplyr::starwars # Vamos visualizar o dado dplyr::glimpse(starwars) ## Observations: 87 ## Variables: 13 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, &quot;Leia O‚Ä¶ ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, 180, ‚Ä¶ ## $ mass &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 84.0, 77‚Ä¶ ## $ hair_color &lt;chr&gt; &quot;blond&quot;, NA, NA, &quot;none&quot;, &quot;brown&quot;, &quot;brown, grey&quot;, &quot;brown&quot;, ‚Ä¶ ## $ skin_color &lt;chr&gt; &quot;fair&quot;, &quot;gold&quot;, &quot;white, blue&quot;, &quot;white&quot;, &quot;light&quot;, &quot;light&quot;, ‚Ä¶ ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;brown&quot;, &quot;blue&quot;, &quot;blue&quot;‚Ä¶ ## $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0, 57.0,‚Ä¶ ## $ gender &lt;chr&gt; &quot;male&quot;, NA, NA, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, NA, &quot;m‚Ä¶ ## $ homeworld &lt;chr&gt; &quot;Tatooine&quot;, &quot;Tatooine&quot;, &quot;Naboo&quot;, &quot;Tatooine&quot;, &quot;Alderaan&quot;, &quot;‚Ä¶ ## $ species &lt;chr&gt; &quot;Human&quot;, &quot;Droid&quot;, &quot;Droid&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Hum‚Ä¶ ## $ films &lt;list&gt; [&lt;&quot;Revenge of the Sith&quot;, &quot;Return of the Jedi&quot;, &quot;The Empir‚Ä¶ ## $ vehicles &lt;list&gt; [&lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &quot;I‚Ä¶ ## $ starships &lt;list&gt; [&lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;, &lt;&gt;, &lt;&gt;, &quot;TIE Advanced x1‚Ä¶ # Vamos ver a m√©dia de ano de nascimento mean(starwars$birth_year) ## [1] NA # Observe que o NA gera um erro na nossa m√©dia, vamos remov√™-lo mean(starwars$birth_year, na.rm = TRUE) ## [1] 87.56512 # Mediana median(starwars$birth_year, na.rm = TRUE) ## [1] 52 # Podemos procurar pela menor data de nascimento min(starwars$birth_year, na.rm = TRUE) ## [1] 8 # Pelo m√°ximo tamb√©m max(starwars$birth_year, na.rm = TRUE) ## [1] 896 # Desvio padr√£o sd(starwars$birth_year, na.rm = TRUE) ## [1] 154.6914 2.3 Estruturas de decis√£o No R, os IF's da vida - ‚Äúse chover e fizer frio, n√£o vou √† praia‚Äù possuem uma estrutura semelhante ao Java. A seguir, s√£o apresentados exemplos das estruturas de decis√£o do R com o uso do conjunto de dados star wars. personagem &lt;- &quot;BB8&quot; if(personagem %in% starwars$name){ &quot;Tem o personagem BB8 nos dados&quot; } else if(&quot;Padm√©&quot; %in% starwars$name) { &quot;Tem a personagem Padm√© nos dados&quot; } else { &quot;N√£o possui esse personagem&quot; } ## [1] &quot;Tem o personagem BB8 nos dados&quot; 2.4 Itera√ß√£o Em R para iterar sobre objetos como lists ou vectors utiliza-se o comando de repti√ß√£o for. A sintaxe para utilizar o comando for no R √© semelhante ao comando em Python. Na c√©lula abaixo √© apresentado um exemplo de foreach ‚Äúpara cada elemento da estrutura fa√ßa‚Äù na linguagem R: # Foreach for(i in head(starwars$name, 3)){ print(i) } ## [1] &quot;Luke Skywalker&quot; ## [1] &quot;C-3PO&quot; ## [1] &quot;R2-D2&quot; 2.5 Manipula√ß√£o de dados Vamos utilizar o pacote dplyr do kit de ferramentas Tidyverse para manipular os valores de um data.frame. Para isso, criamos o seguinte data.frame: meu_df &lt;- tibble::tibble( aluno_id = c(1, 2, 3, 4, 5, 6), aluno_sexo = c(&quot;Masculino&quot;, &quot;Feminino&quot;,&quot;Masculino&quot;, &quot;Feminino&quot;, &quot;Masculino&quot;, &quot;Feminino&quot;), aluno_curso = c(&quot;Hist√≥ria&quot;, &quot;Hist√≥ria&quot;, &quot;Matem√°tica&quot;, &quot;Estat√≠stica&quot;, &quot;Matem√°tica&quot;, &quot;Estat√≠stica&quot;), aluno_media = c(2.1, 3.5, 4.0, 1.0, NA, 4.9), aluno_avaliacao = c(&quot;Ruim&quot;, &quot;Ruim&quot;, &quot;Excelente&quot;, &quot;Ruim&quot;, &quot;Nenhum&quot;, &quot;Excelente&quot;)) aluno_id aluno_sexo aluno_curso aluno_media aluno_avaliacao 1 Masculino Hist√≥ria 2.1 Ruim 2 Feminino Hist√≥ria 3.5 Ruim 3 Masculino Matem√°tica 4.0 Excelente 4 Feminino Estat√≠stica 1.0 Ruim 5 Masculino Matem√°tica NA Nenhum 6 Feminino Estat√≠stica 4.9 Excelente A seguir s√£o descritos os m√©todo do pacote dplyr utilizados nos exemplos: select - Sele√ß√£o de atributos de um Data Frame; filter - Filtro de observa√ß√µes de acordo com uma l√≥gica pr√©-definida; mutate - Cria√ß√£o de novos atributos; group_by - Cria√ß√£o de grupos para aplica√ß√£o de fun√ß√µes de agrega√ß√£o; summarize - Fun√ß√£o de agrega√ß√£o aplicada em grupos. Com base nos m√©todos acima, vamos manipular nosso ‚ÄãData Frame‚Äã ? # Importa√ß√£o do pacote dplyr library(dplyr) # Filtro pelo atributo &quot;aluno_avaliano&quot; filtro &lt;- dplyr::filter(meu_df, meu_df$aluno_avaliacao == &quot;Ruim&quot;) # Sele√ß√£o dos atributos &quot;aluno_curso&quot;, &quot;aluno_avaliacao&quot; e &quot;aluno_media&quot; selecao &lt;- dplyr::select(filtro, aluno_curso, aluno_avaliacao, aluno_media) # Cria√ß√£o de um grupo de cursos grupo &lt;- dplyr::group_by(selecao, aluno_curso) # Agrega√ß√£o pela m√©dia de cada curso media &lt;- dplyr::summarize(grupo, media_grupo = mean(aluno_media)) aluno_curso media_grupo Estat√≠stica 1.0 Hist√≥ria 2.8 No exemplo acima foram realizadas algumas opera√ß√µes sobre o data.frame. Sobre o resultado da filtragem foi feita a sele√ß√£o dos atributos aluno_curso, aluno_avaliacao e aluno_media. A partir da sele√ß√£o dos atributos agrupamos os dados segundo o atributo aluno_curso. E por fim, calculamos a m√©dia do atributo aluno_media revelando o curso e a m√©dia dos alunos que obtiveram uma avalia√ß√£o ruim üêª. Mas, o c√≥digo ficou muito grande, como podemos melhorar? Substituindo por apenas uma vari√°vel, desta forma: # Filtro pelo atributo &quot;aluno_avaliano&quot; meu_df1 &lt;- dplyr::filter(meu_df, meu_df$aluno_avaliacao ==&quot;Ruim&quot;) # Sele√ß√£o dos atributos &quot;aluno_curso&quot;, &quot;aluno_avaliacao&quot; e &quot;aluno_media&quot; meu_df1 &lt;- dplyr::select(meu_df1, aluno_curso, aluno_avaliacao, aluno_media) # Cria√ß√£o de um grupo de cursos meu_df1 &lt;- dplyr::group_by(meu_df1, aluno_curso) # Agrega√ß√£o pela m√©dia de cada curso meu_df1 &lt;- dplyr::summarize(meu_df1, media_grupo = mean(aluno_media)) aluno_curso media_grupo Estat√≠stica 1.0 Hist√≥ria 2.8 Melhorou um pouco, n√£o? Mas podemos melhorar ainda mais utilizando o s√≠mbolo %&gt;%. O %&gt;% √© chamado de pipe ela √© permite com que a resposta da primeira atribui√ß√£o seja utilizada como primeiro par√¢metro da fun√ß√£o seguinte, desta forma: meu_vetor &lt;- c(1, 3, 5, 7, 9) %&gt;% mean() meu_vetor ## [1] 5 A partir disto n√£o precisamos usar a vari√°vel meu_vetor como par√¢metro da fun√ß√£o mean(). Mas e se eu quiser adicionar mais par√¢metros? Opa, voc√™ pode e deve! Isso segue a mesma linha de racioc√≠nio da fun√ß√£o, desta forma: meu_vetor &lt;- c(2, 4, 6, 8, NA) %&gt;% mean(na.rm=TRUE) meu_vetor ## [1] 5 Agora, vamos otimizar nossa manipula√ß√£o usando pipe da seguinte maneira: # exemplo de uso do operador pipe df &lt;- meu_df %&gt;% filter(aluno_avaliacao == &quot;Ruim&quot;) %&gt;% select(aluno_curso, aluno_avaliacao, aluno_media) %&gt;% group_by(aluno_curso) %&gt;% summarize(media_grupo = mean(aluno_media)) aluno_curso media_grupo Estat√≠stica 1.0 Hist√≥ria 2.8 Essa √© a principal fun√ß√£o do operador pipe, tornar o c√≥digo mais limpo e reprodut√≠vel. 2.6 Exemplos Para encerrarmos esse cap√≠tulo de R, vamos mostrar uma an√°lise de dados aplicada no mundo real. Para isso, iremos utilizar dois conjuntos de dados obtidos atrav√©s da plataforma kaggle. Os conjuntos de dados correspondentes a s√©rie temporal de mudan√ßa clim√°tica da temperatura da superf√≠cie terrestre terrestre e os continentes de cada pa√≠s. O objetivo da an√°lise √© verificar qual continente registrou a maior m√©dia anual de temperatura. # Importa√ß√£o dos pacotes utilizados library(readr) # Leitura de dados retangulares library(dplyr) # M√©todos para manipula√ß√£o de dados library(lubridate) # M√©todos para trabalhar com dados do tipo date # Leitura dos dados de mudan√ßa clim√°tica temperature_countries &lt;- readr::read_csv(&quot;./data/GlobalLandTemperaturesByCountry.csv&quot;) # Leitura e sele√ß√£o dos dados de continentes continent &lt;- readr::read_csv(&quot;./data/countryContinent.csv&quot;) %&gt;% dplyr::select(country, continent) # Sele√ß√£o do atributo continente # Filtro a partir do ano 2000 e extra√ß√£o da m√©dia anual (talvez n√£o seja a melhor abordagem) year_temperature &lt;- temperature_countries %&gt;% dplyr::filter(dt &gt; &quot;2000-01-01&quot;) %&gt;% # Filtro a partir do ano 2000 dplyr::mutate(dt = lubridate::year(dt)) %&gt;% # Transformando pro tipo date dplyr::group_by(Country, dt) %&gt;% # Criando um grupo de pa√≠ses dplyr::summarise(year_mean = mean(AverageTemperature)) # Agrega√ß√£o pela m√©dia # Jun√ß√£o dos continentes com cada pa√≠s final_dataset &lt;- year_temperature %&gt;% dplyr::rename(country = Country) %&gt;% # Alterando o nome do atributo dplyr::left_join(continent, by=&quot;country&quot;) %&gt;% # Jun√ß√£o dos dois conjuntos dplyr::filter(!is.na(continent)) # Remo√ß√£o dos valores NA # Visualiza√ß√£o dos dados head(final_dataset, 5) ## # A tibble: 5 x 4 ## # Groups: country [1] ## country dt year_mean continent ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 2000 16.7 Asia ## 2 Afghanistan 2001 15.8 Asia ## 3 Afghanistan 2002 15.5 Asia ## 4 Afghanistan 2003 14.9 Asia ## 5 Afghanistan 2004 15.8 Asia Agora vamos responder a nossa pergunta: qual o continente que registrou a maior temperatura anual? # Cria√ß√£o de um grupo de continentes e agregando pela maior temperatura final_dataset %&gt;% dplyr::group_by(continent) %&gt;% # Grupo de continentes summarise(maior_temp = max(year_mean, na.rm = TRUE)) # Agrega√ß√£o pela temp max ## # A tibble: 5 x 2 ## continent maior_temp ## &lt;chr&gt; &lt;dbl&gt; ## 1 Africa 30.3 ## 2 Americas 29.0 ## 3 Asia 29.7 ## 4 Europe 20.3 ## 5 Oceania 27.9 A partir desta an√°lise inicial, podemos gerar outras perguntas, por exemplo, qual o ano com a maior m√©dia de temperatura registrada ? # Cria√ß√£o de um grupo de anos e agrega√ß√£o pelo valor da temperatura, por fim ordena√ß√£o pelos valores de temperatura final_dataset %&gt;% dplyr::group_by(dt) %&gt;% # Grupo dos anos dplyr::summarise(maior_temp = max(year_mean, na.rm = TRUE)) %&gt;% # Agrega√ß√£o pelo max dplyr::arrange(desc(maior_temp)) %&gt;% # Ordena√ß√£o pela temperatura head(5) ## # A tibble: 5 x 2 ## dt maior_temp ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2000 30.3 ## 2 2010 30.1 ## 3 2012 29.9 ## 4 2009 29.9 ## 5 2011 29.8 Enfim, podemos responder diversas perguntas com poucas linhas de c√≥digo. Esperamos que este cap√≠tulo tenha despertado sua curiosidade sobre an√°lise de dados. Os materiais base utilizados para cria√ß√£o deste cap√≠tulo se encontram nesta subse√ß√£o. 2.7 Para saber mais Este foi s√≥ o come√ßo! Para continuar e aprender mais, consulte: N√∫meros complexos Tipos num√©ricos em R Diferen√ßa entre lista e vetor Documenta√ß√£o do CRAN R eficiente R 4 Data Science Material da mat√©ria CAP-394 (INPE) "],
["introdu√ß√£o-ao-python.html", "3 Introdu√ß√£o ao Python üöÄ 3.1 Introdu√ß√£o ao Pandas üêº 3.2 Estruturas de dados 3.3 Exemplos 3.4 Para saber mais", " 3 Introdu√ß√£o ao Python üöÄ Python √© uma linguagem multiparadigma, com uma sintaxe simples que permite ao utilizador focar no problema e deixar de lado qualquer tipo de especificidade. A linguagem vem sendo amplamente utilizada em diversas √°reas, por conta das milhares de bibliotecas que possui, boa parte dessas distribu√≠das pela incr√≠vel comunidade da linguagem ‚ù§Ô∏è. Nesta introdu√ß√£o, o foco ser√° a aplica√ß√£o da linguagem Python na manipula√ß√£o e tratamento de dados, utilizando como base a biblioteca Pandas. Voc√™ pode estar se perguntando o motivo da utiliza√ß√£o desta biblioteca e a resposta √© bem simples. Python √© uma linguagem de uso geral, assim, suas fun√ß√µes nativas n√£o tem como foco uma aplica√ß√£o espec√≠fica. Isso diferencia o Python de linguagens como R e Julia, que possuem √°reas espec√≠ficas de aplica√ß√£o. Com isso, n√£o podemos esperar que nativamente a linguagem tenha m√©todos variados para a manipula√ß√£o e tretamento de dados e √© nessa parte que o Pandas trabalha, facilitando toda a manipula√ß√£o e tratamento de dados com fun√ß√µes incr√≠veis. Vamos come√ßar ! 3.1 Introdu√ß√£o ao Pandas üêº Para iniciar, vamos entender o que √© a biblioteca Pandas e qual seu objetivo geral, para isso, vejamos a defini√ß√£o feita na documenta√ß√£o oficial do projeto. Pandas √© uma biblioteca open source, licenciada pelo BSD, que fornece estruturas de dados de alto desempenho e f√°ceis de usar e ferramentas de an√°lise de dados para a linguagem de programa√ß√£o Python. Veja ent√£o que, o Pandas possui quase tudo o que √© necess√°rio para a realiza√ß√£o de um projeto de an√°lise de dados na linguagem Python. Isso faz com que a biblioteca seja a principal ferramenta Python para a √°rea de Data Science. Para se ter uma ideia, o Pandas pode ser aplicado em an√°lises envolvendo: Finan√ßas; Geoci√™ncias; Ci√™ncia social; Al√©m de diversas outras √°reas de ci√™ncias e engenharia. Nos pr√≥ximos t√≥picos ser√£o abordadas as principais fun√ß√µes e estruturas de dados do Pandas, evidenciando o qu√£o f√°cil √© a utiliza√ß√£o da ferramenta. 3.2 Estruturas de dados O Pandas disponibiliza diversas estruturas de dados preparadas para o trabalho com grandes volumes de dados, sendo as principais: Series; DataFrames. Nos subt√≥picos abaixo vamos ver as caracter√≠sticas de cada uma dessas estruturas, e em seguida, veremos alguns utilit√°rios para leitura de dados com Pandas. 3.2.1 Series As Series s√£o estruturas unidimensionais, que contam com diversos m√©todos para a manipula√ß√£o de dados. Pode-se entender que as Series s√£o estruturas de dados simples, assim como as listas padr√µes da linguagem Python, com uma pequena diferen√ßa, os items dentro de uma Series possuem um √≠ndice. Para entendermos como a estrutura funciona, vamos apresentar alguns exemplos de como criar e manipular as Series. No c√≥digo abaixo, inicialmente √© realizada a importa√ß√£o do Pandas com o ‚Äòapelido‚Äô de pd. Em seguida criamos uma Series simples, passando como par√¢metro de entrada uma lista com tr√™s valores, veja: import pandas as pd s = pd.Series([1, 2, 3]); print(s) ## 0 1 ## 1 2 ## 2 3 ## dtype: int64 Ao fazer pd.Series, voc√™ est√° explicitamente informando que a estrutura de dados Series est√° no contexto da biblioteca Pandas. √â interessante notar que cada elemento da Series possui um √≠ndice associado. Este √≠ndice permite a recupera√ß√£o r√°pida e simples dos dados que comp√µem a Series. A recupera√ß√£o feita atrav√©s de √≠ndices √© muito parecida com a recupera√ß√£o de valores em um dicion√°rio em Python. Abaixo √© apresentado um exemplo de como indexar e recuperar um elemento da Series: print(s[0]) # Recupera o valor do √≠ndice com nome 0 ## 1 Atrav√©s do atributo index √© poss√≠vel visualizar os √≠ndices associados a estrutura: print(s.index) ## RangeIndex(start=0, stop=3, step=1) O √≠ndice pode ser facilmente editado como segue: s.index = [&quot;um&quot;, &quot;dois&quot;, &quot;tres&quot;] print(s.index) ## Index([&#39;um&#39;, &#39;dois&#39;, &#39;tres&#39;], dtype=&#39;object&#39;) Tamb√©m √© poss√≠vel j√° criar uma Series com um √≠ndice personalizado, para isto, basta passar como par√¢metro do construtor da Series uma segunda lista com os valores dos √≠ndices. s = pd.Series([7, 8, 9], [1, 2, 3]) # ou s = pd.Series([7, 8, 9], index=[1, 2, 3]) # Fica explicito quem √© o √≠ndice Note que a primeira lista passada representa os dados, e a segunda o √≠ndice. print(s) ## 1 7 ## 2 8 ## 3 9 ## dtype: int64 √â poss√≠vel criar uma Series atrav√©s de um dicion√°rio Python. Veja o exemplo: dicto = { &#39;instituto&#39;: &#39;INPE&#39;, &#39;nota&#39;: 10 } dicto_s = pd.Series(dicto); print(dicto_s) ## instituto INPE ## nota 10 ## dtype: object Ap√≥s a constru√ß√£o o uso √© basicamente o mesmo do dicion√°rio. Al√©m do que j√° foi dito sobre as Series, √© importante lembrar que, estas estruturas de dados possuem diversos m√©todos para facilitar a manipula√ß√£o e entendimento dos dados, apresentados nas pr√≥ximas se√ß√µes. Mesmo as Series sendo estruturas de dados poderosas, elas apresentam a limita√ß√£o da unidimensionalidade. Isso impede que estruturas N-dimensionais (Como por exemplo, matrizes, tabelas e similares) n√£o possam ser facilmente representadas atrav√©s das Series. Para exemplificar este impedimento, vamos inserir uma matriz de dados em uma Series, erros n√£o ser√£o apresentados, por√©m, a representa√ß√£o pode n√£o ficar como desejado. matriz = pd.Series([[1, 2, 3], [4, 5, 6]]) print(matriz) ## 0 [1, 2, 3] ## 1 [4, 5, 6] ## dtype: object Percebeu ? N√£o h√° uma matriz, e sim listas de listas associadas aos √≠ndices. A ideia √© que a matriz fosse apresentada em um formato onde cada elemento est√° em uma posi√ß√£o, como na tabela abaixo. 1 2 3 4 5 6 Para estes casos √© necess√°rio o uso de uma outra estrutura de dados, o DataFrame, tratado no subt√≥pico seguinte. 3.2.2 DataFrames Agora que voc√™ j√° conhece como as Series funcionam, vamos apresentar a voc√™ o DataFrame. O DataFrame difere das Series por ser uma estrutura multidimensional, ou seja, trabalha com linhas e colunas. Boa parte dos m√©todos dispon√≠veis em uma Series tamb√©m s√£o aplic√°veis em DataFrames, o que ajuda no aprendizado da utiliza√ß√£o da API do Pandas. √â importante entender que, o fato de haver mais dimens√µes nos dados torna a manipula√ß√£o diferente, com resultados diferentes (Isto para os mesmos m√©todos). Vejamos algumas caracter√≠sticas bacanas dos DataFrames: matriz = pd.DataFrame([[1, 2, 3], [4, 5, 6]]) print(matriz) ## 0 1 2 ## 0 1 2 3 ## 1 4 5 6 O processo acima quando realizado nas Series, gera listas de listas. Por√©m com os DataFrames tem-se uma matriz com formas de recupera√ß√£o por linhas e colunas. Da mesma forma que as Series, os DataFrames permitem que os √≠ndices sejam (re)nomeados, al√©m disso, as colunas tamb√©m podem ser (re)nomeadas e utilizadas para a recupera√ß√£o de dados. tabela = pd.DataFrame([[.9, .8, .7], [.4, .5, .7]], columns = [&#39;primeiro&#39;, &#39;segundo&#39;, &#39;terceiro&#39;], index = [&#39;zero&#39;, &#39;um&#39;]) print(tabela) ## primeiro segundo terceiro ## zero 0.9 0.8 0.7 ## um 0.4 0.5 0.7 Um DataFrame tamb√©m pode ser criado atrav√©s de um dicion√°rio, veja como isso √© feito: dicto = { &#39;nome&#39;: [&#39;felipe&#39;, &#39;maria&#39;], &#39;idade&#39;: [12, 13] } df = pd.DataFrame(dicto); print(df) ## nome idade ## 0 felipe 12 ## 1 maria 13 Bem, agora que voc√™ entendeu a diferen√ßa fundamental entre essas estruturas de dados, vamos aprender sobre diferentes m√©todos para a manipula√ß√£o dessas estruturas. 3.2.3 Sele√ß√£o e filtro dos dados Uma parte muito importante √© a sele√ß√£o e filtragem dos dados. Vamos come√ßar fazendo a busca utilizando os √≠ndices (index) e as colunas (No caso dos DataFrames). Para isto, utilizamos os m√©todos .loc, que permitem buscar uma linha com algum nome de √≠ndice espec√≠fico e o .iloc que busca uma linha em uma posi√ß√£o espec√≠fica. A sintaxe de utiliza√ß√£o b√°sica para as duas estruturas de dados podem ser vistas abaixos: DataFrame Series .loc[Nome da linha, Nome da coluna] .loc[Nome da linha] .iloc[posi√ß√£o da linha, posi√ß√£o da coluna] .iloc[posi√ß√£o da linha] Note as diferen√ßas de sintaxe em rela√ß√£o a estrutura de dados (Series ou DataFrames) adotada. Os m√©todos mudam pela quantidade de par√¢metros que podem ser utilizados. O .loc e .iloc permitem a busca por linhas e colunas nos DataFrames e somente das linhas em uma Series. df = pd.DataFrame({ &#39;nome&#39;: [&#39;Joana&#39;, &#39;Maria&#39;, &#39;Josefa&#39;], &#39;idade&#39;: [15, 18, 21], &#39;nota&#39;: [8, 9, 10] }, index = [7, 8, 9]) # Recuperando o nome da aluna com index 9 df.loc[9, &#39;nome&#39;] # √â poss√≠vel tamb√©m recuperar mais de uma coluna com o .loc ## &#39;Josefa&#39; df.loc[9, [&#39;nome&#39;, &#39;idade&#39;]] # Recuperando a aluna na posi√ß√£o 2 ## nome Josefa ## idade 21 ## Name: 9, dtype: object df.iloc[2][&#39;nome&#39;] # Recuperando duas colunas ## &#39;Josefa&#39; df.iloc[2][[&#39;nome&#39;, &#39;idade&#39;]] # Recuperando a linha 1 (√çndice 8) e coluna 1 (Idade) ## nome Josefa ## idade 21 ## Name: 9, dtype: object df.iloc[1, 1] ## 18 Ambas estruturas tamb√©m permitem a utiliza√ß√£o de express√µes booleanas para filtragem dos dados. No exemplo abaixo √© instanciado um DataFrame de valores num√©ricos. O objetivo √© selecionar todos elementos do DataFrame maiores ou iguais a 5. df = pd.DataFrame({&#39;numeros&#39;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}) df[df[&#39;numeros&#39;] &gt;= 5] ## numeros ## 4 5 ## 5 6 ## 6 7 ## 7 8 ## 8 9 ## 9 10 O exemplo utilizou um DataFrame, mas as express√µes booleanas tamb√©m podem ser aplicadas nas Series. Esses s√£o os conceitos b√°sicos para a manipula√ß√£o e filtragem dos dados. Existem diversas fun√ß√µes e m√©todos que podem ser utilizados para esse fim. Inicialmente veremos somente parte deles, por√©m, s√≥ com o que vimos at√© aqui j√° √© poss√≠vel realizar grande parte das etapas de an√°lise de dados. 3.2.4 Agrupamento de dados e agrega√ß√µes Muitas vezes quereos agrupar nossos dados para obter informa√ß√µes, seja para facilitar a manipula√ß√£o, o entendimento das rela√ß√µes contidas nos dados, ou mesmo para aplicar fun√ß√µes sobre cada um dos grupos e obter informa√ß√µes a partir disto. Para isso podemos utilizar diferentes formas de agrupamentos e agrega√ß√µes. O termo agrega√ß√µes pode apresentar diferentes defini√ß√µes, aqui foi assumido que, ‚ÄúAgrega√ß√µes s√£o opera√ß√µes aplicadas sobre os dados que resultam em um conjunto de valores‚Äù. No Pandas, o retorno de uma agrega√ß√£o pode mudar de acordo com a estrutura de dados, no caso das Series √© retornado apenas um valor escalar. Para os DataFrames, o retorno da agrega√ß√£o √© um valor para cada linha ou coluna (A dimens√£o pode ser definida pelo usu√°rio). Algumas opera√ß√µes de agrega√ß√£o s√£o: sum() -&gt; Realiza somat√≥rio; min() -&gt; Busca o valor m√≠nimo; max() -&gt; Busca o valor m√°ximo; count() -&gt; Realiza a contagem de elementos. s = pd.Series([1, 2, 3]) df = pd.DataFrame([[1, 2, 3,], [4, 5, 6]]) # Agregando Series print(s.sum()) # Agregando DataFrame ## 6 print(df.sum()) ## 0 5 ## 1 7 ## 2 9 ## dtype: int64 Por outro lado, as opera√ß√µes de agrupamento realizam a divis√£o dos dados em conjuntos que possuem alguma similaridade. No Pandas o agrupamento √© realizado com o m√©todo groupby presente nas Series e DataFrames. O crit√©rio de similaridade utilizado nas opera√ß√µes de agrupamento s√£o definidos pelo usu√°rio. Aqui vamos focar no agrupamento dos DataFrames, mas os passos s√£o os mesmos para as Series. df = pd.DataFrame({ &#39;nome&#39;: [&#39;Tel1&#39;, &#39;Tel2&#39;, &#39;Tel3&#39;], &#39;tipo&#39;: [&#39;antigo&#39;, &#39;novo&#39;, &#39;novo&#39;] }) # Etapa de divis√£o dos dados agrupado = df.groupby(&#39;tipo&#39;) No exemplo acima, os dados foram agrupados de acordo com a coluna tipo. No caso, os elementos que possuem o mesmo valor do atributo tipo s√£o agrupados por linhas. Certo, a opera√ß√£o √© simples e intuitiva, mas o que devemos esperar deste m√©todo ? Intuitivamente pensamos em um conjunto de DataFrames, onde cada DataFrame representa um grupo. Esse √© exatamente o retorno do Pandas, por√©m, h√° algumas particulariedades. O tipo retornado de uma opera√ß√£o groupby deixa de ser um DataFrame e passa a ser um DataFrameGroupBy. Isso facilita a manipula√ß√£o dos grupos com m√©todos especializados. Vamos iniciar o entendimento do DataFrameGroupBy pela verifica√ß√£o dos grupos criados. Esse processo √© feito atrav√©s do atributo groups. print(agrupado.groups) ## {&#39;antigo&#39;: Int64Index([0], dtype=&#39;int64&#39;), &#39;novo&#39;: Int64Index([1, 2], dtype=&#39;int64&#39;)} Acessando o atributo groups √© poss√≠vel verificar todos os grupos gerados e seus membros. Al√©m disto, com um objeto DataFrameGroupBy √© poss√≠vel aplicarmos os conceitos de agrega√ß√£o dentro dos grupos gerados pelo groupby. Para entendermos o funcionamento do processo de agrupamento e agrega√ß√£o juntos, vejamos a defini√ß√£o feita por Hadley Wickham: ‚ÄúO processo de dividir √© o agrupamento, onde os dados s√£o agrupados de acordo com alguma caracter√≠stica definida previamente, a aplica√ß√£o realiza as agrega√ß√µes, filtros ou transforma√ß√µes e por fim a combina√ß√£o, que representa a jun√ß√£o dos resultados das etapas anteriores‚Äù Na defini√ß√£o o processo √© dividido nas etapas Dividir-Aplicar-Combinar. Na figura abaixo √© apresentado um fluxograma das diferentes etapas deste processo. Para aprimorar o entendimento vamos criar um exemplo. df = pd.DataFrame({ &#39;nome&#39;: [&#39;felipe&#39;, &#39;jo√£o&#39;, &#39;maria&#39;, &#39;ana&#39;], &#39;idade&#39;: [19, 19, 20, 20], &#39;dinheiro&#39;: [100, 100, 150, 150] }) No c√≥digo apresentado abaixo √© realizado um agrupamento levando em considera√ß√£o o atributo idade. # Esta √© a etapa de divir, da defini√ß√£o do Hedley agrupado = df.groupby(&#39;idade&#39;) # Aplicando uma agrega√ß√£o ## Esta √© a etapa de aplica√ß√£o e jun√ß√£o, definida pelo Hedley print(agrupado.count()) ## nome dinheiro ## idade ## 19 2 2 ## 20 2 2 Veja que o resultado do agrupamento apresenta o valor do atributo idade e a quantidade de elementos associados ao grupo. Mas √© poss√≠vel aplicar a agrega√ß√£o em uma coluna espec√≠fica ? Sim, √© poss√≠vel! # Agregando somente o dinheiro de cada grupo print(agrupado[&#39;dinheiro&#39;].sum()) ## idade ## 19 200 ## 20 300 ## Name: dinheiro, dtype: int64 Pronto! No exemplo acima √© apresentado um exemplo de como agregar uma coluna espec√≠fica no caso o atributo dinheiro. Com estes m√©todos de manipula√ß√£o j√° √© poss√≠vel resolver diversos problemas do mundo real! 3.2.5 Fun√ß√µes de leitura e escrita de dados Al√©m das estruturas de dados poderosas, o pandas tamb√©m possui fun√ß√µes para leitura e escrita de dados que facilitam muito a vida üöÄ. Como existem muitas fun√ß√µes para leitura e escrita, aqui ser√£o apresentadas apenas algumas. Para conhecer outras fun√ß√µes de leitura e escrita n√£o deixe de conferir a documenta√ß√£o do projeto. Caso voc√™ esteja trabalhando com dados estruturados salvos em um arquivo .csv, existe a fun√ß√£o read_csv para te ajudar. df = pd.read_csv(&#39;data/titanic.csv&#39;) # O caminho pode ser diferente eu sua m√°quina O ponto importante a ser notado √© que, os dados quando carregados com as fun√ß√µes do Pandas, sempre ser√£o alocados em mem√≥ria como uma Series ou DataFrame. Com a fun√ß√£o type vamos verificar qual o tipo do dado carregado. type(df) ## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Observe que o dado ao ser lido √© representado como uma DataFrame. Portanto, podemos utilizar todos os m√©todos j√° vistos at√© aqui. Existem algumas formas de visualizar os dados carregados. A seguir s√£o apresentados exemplos das fun√ß√µes head e tail que respectivamente recuperam o in√≠cio e o final do DataFrame. print(df.head()) # Fun√ß√£o que mostra o in√≠cio do DataFrame carregado ## PassengerId Pclass Name ... Fare Cabin Embarked ## 0 892 3 Kelly, Mr. James ... 7.8292 NaN Q ## 1 893 3 Wilkes, Mrs. James (Ellen Needs) ... 7.0000 NaN S ## 2 894 2 Myles, Mr. Thomas Francis ... 9.6875 NaN Q ## 3 895 3 Wirz, Mr. Albert ... 8.6625 NaN S ## 4 896 3 Hirvonen, Mrs. Alexander (Helga E Lindqvist) ... 12.2875 NaN S ## ## [5 rows x 11 columns] print(df.tail()) # Fun√ß√£o que mostra o final do DataFrame carregado ## PassengerId Pclass Name Sex ... Ticket Fare Cabin Embarked ## 413 1305 3 Spector, Mr. Woolf male ... A.5. 3236 8.0500 NaN S ## 414 1306 1 Oliva y Ocana, Dona. Fermina female ... PC 17758 108.9000 C105 C ## 415 1307 3 Saether, Mr. Simon Sivertsen male ... SOTON/O.Q. 3101262 7.2500 NaN S ## 416 1308 3 Ware, Mr. Frederick male ... 359309 8.0500 NaN S ## 417 1309 3 Peter, Master. Michael J male ... 2668 22.3583 NaN C ## ## [5 rows x 11 columns] Caso os dados que voc√™ est√° trabalhando sejam oriundos de algum servi√ßo web, o Pandas tamb√©m pode te ajudar! Com o m√©todo read_json voc√™ pode passar n√£o s√≥ o nome do arquivo json em sua m√°quina, mas tamb√©m a URL do servi√ßo web que distribui tais dados. Como exemplo vamos recuperar dados de uma API Rest de exemplo. json_frame = pd.read_json(&#39;http://dummy.restapiexample.com/api/v1/employees&#39;) print(json_frame.head()) ## status data message ## 0 success {&#39;id&#39;: 1, &#39;employee_name&#39;: &#39;Tiger Nixon&#39;, &#39;emp... Successfully! All records has been fetched. ## 1 success {&#39;id&#39;: 2, &#39;employee_name&#39;: &#39;Garrett Winters&#39;, ... Successfully! All records has been fetched. ## 2 success {&#39;id&#39;: 3, &#39;employee_name&#39;: &#39;Ashton Cox&#39;, &#39;empl... Successfully! All records has been fetched. ## 3 success {&#39;id&#39;: 4, &#39;employee_name&#39;: &#39;Cedric Kelly&#39;, &#39;em... Successfully! All records has been fetched. ## 4 success {&#39;id&#39;: 5, &#39;employee_name&#39;: &#39;Airi Satou&#39;, &#39;empl... Successfully! All records has been fetched. print(json_frame.columns) # Recupera as colunas do DataFrame ## Index([&#39;status&#39;, &#39;data&#39;, &#39;message&#39;], dtype=&#39;object&#39;) Da mesma forma que a leitura, fazer escrita de dados com pandas √© muito simples. Tendo os dados sobre uma Series ou DataFrame √© poss√≠vel salvar os dados em diferentes formatos. Por exemplo, o m√©todo to_csv pode ser utilizado para salvar uma Series ou um DataFrame em um arquivo .csv. Mas caso voc√™ queira salvar em um arquivo json, basta trocar o m√©todo to_csv para to_json e pronto! Seus dados estar√£o disponibilizados no sistema de arquivos nos formatos indicados. df.to_csv(&#39;nome_do_csv.csv&#39;) # Salva o CSV df.to_json(&#39;nome_do_json.json&#39;) # Salva o JSON Viu ? √â tudo muito simples e direto, o que te permite focar em sua an√°lise e deixar de lado problemas com sintaxe üóΩ. Para fechar esta se√ß√£o de an√°lise de dados com Python e Pandas, ser√° apresentado um exemplo de an√°lise que pode ser utilizada em aplica√ß·∫Ωos reais. 3.3 Exemplos Para o exemplo foi utilizado o conjunto de dados Meteorite Landings retirados da plataforma Kaggle. O conjunto de dados consistem em mais de 45 mil registros de meteoros que atingiram a Terra. Para iniciar a an√°lise inicialmente importamos a biblioteca Pandas. import pandas as pd Depois de importar a biblioteca, fa√ßa a importa√ß√£o dos dados df = pd.read_csv(&#39;./data/meteorite-landings.csv&#39;) Fazer an√°lise de dados √© responder perguntas, matar a curiosidade, ent√£o, na an√°lise feita, algumas perguntas ser√£o feitas para que a an√°lise tenha algum objetivo. Para come√ßar, vamos verificar o tipo de dado que foi devolvido da fun√ß√£o read_csv utilizada para carregar os dados. type(df) ## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Beleza, √© um DataFrame, isso indica que vamos conseguir aplicar os m√©todos que vimos anteriormente sem problemas. Agora vamos verificar as dimens√µes que a tabela representa no DataFrame possui. Para tal, o atributo shape ser√° utilizado. # Verificando a dimens√£o dos dados df.shape ## (45716, 10) Interessante! Os valores (45716, 10), indicam respectivamente que, o conjunto de dados possui 45716 linhas e 10 colunas. Por falar nas colunas, vamos verificar quais s√£o as colunas dispon√≠veis neste conjunto de dados. # Verificando as colunas df.columns ## Index([&#39;name&#39;, &#39;id&#39;, &#39;nametype&#39;, &#39;recclass&#39;, &#39;mass&#39;, &#39;fall&#39;, &#39;year&#39;, &#39;reclat&#39;, ## &#39;reclong&#39;, &#39;GeoLocation&#39;], ## dtype=&#39;object&#39;) A descri√ß√£o de cada coluna est√° dispon√≠vel na p√°gina dos dados, n√£o deixe de conferir para o entendimento completo sobre os m√©todos de an√°lise e os dados. Vamos explorar a coluna nametype, que indica o tipo de meteorito, havendo dois tipos poss√≠veis: Valid: Tipo comum de meteorito; Relict: Meteorito degradado pelo clima da Terra. Para verificar qual tipo possui mais dados vamos dividir o conjunto de dados entre as observa√ß√µes do conjunto do tipo Valid e as observa√ß√µes do tipo Relict. # Separando por tipo de meteorito df_valid = df[df[&#39;nametype&#39;] == &#39;Valid&#39;] df_relict = df[df[&#39;nametype&#39;] == &#39;Relict&#39;] Vamos olhar nas dimens√µes de cada conjunto de dados gerados. df_valid.shape ## (45641, 10) df_relict.shape ## (75, 10) Olha que bacana! J√° √© poss√≠vel perceber que o n√∫mero de meteoritos do tipo Valid √© muito maior que os do tipo Relict. Agora, vamos entender a quantidade de massa m√©dia que cada um desses grupos apresenta. # Agrupando para verificar a massa m√©dia por grupo df_groupby_nametype = df.groupby(&#39;nametype&#39;) df_groupby_nametype_massmean = df_groupby_nametype[&#39;mass&#39;].mean() Vamos olhar o resultado do agrupamento. print(df_groupby_nametype_massmean) ## nametype ## Relict 0.121269 ## Valid 13285.656127 ## Name: mass, dtype: float64 A massa m√©dia (apresentada em gramas) do grupo Valid √© muito maior, o que pode ser explicado pela quantidade no conjunto de dados. Para finalizar, vamos fazer a contagem dos tipos de meteoritos. # Contagem da quantidade de tipos df_groupedby_recclass = df.groupby(&#39;recclass&#39;) df_groupedby_recclass_count = df_groupedby_recclass[&#39;recclass&#39;].count() Por fim, fa√ßamos o filtro do conjunto de dados pela quantidade de massa . # Filtragem (Maior que 500 gramas) df_gt_mass_500 = df[df[&#39;mass&#39;] &gt; 500] df_gt_mass_500.shape # Quantidade bem pequena ## (7036, 10) √â isso, o exemplo mostrou que conhecendo bem a estrutura e sem√¢ntica dos dados e com os m√©todos apresentados no curso √© poss√≠vel extrair v√°rias informa√ß√µes de um conjunto de dados. 3.4 Para saber mais N√£o deixe de buscar mais informa√ß√µes! Abaixo alguns links que podem ser √∫teis. Python Data Science Handbook Documenta√ß√£o - Pandas "],
["introdu√ß√£o-ao-ggplot.html", "4 Introdu√ß√£o ao ggplot üìä 4.1 O que √© o ggplot? 4.2 Mapeamento Est√©tico 4.3 Objetos geom√©tricos 4.4 Escalas 4.5 Subplots (facet) 4.6 Temas 4.7 Exemplos 4.8 Gr√°fico de colunas 4.9 Extens√£o do ggplot2 - Lemon 4.10 Para saber mais", " 4 Introdu√ß√£o ao ggplot üìä A visualiza√ß√£o de dados pode ser considerada uma das mais importantes etapas do processo de an√°lise de dados, √© atrav√©s dela que diversos fen√¥menos presentes nos dados podem ser explicados e visualizados. Quando n√£o souber como explicar, mostre, afinal, uma imagem vale mais que mil palavras. Por√©m, criar formas de visualizar dados pode n√£o ser uma atividade simples, muitas etapas acabam sendo necess√°rias. √â neste contexto que entra o ggplot, uma biblioteca de alto n√≠vel, criada para tornar o processo de visualiza√ß√£o de dados mais simples, possuindo implementa√ß√µes em R com o pacote ggplot2 e em Python com o pacote plotnine, ambos completamente compativeis. Esta se√ß√£o apresenta os conceitos b√°sicos necess√°rios para a utiliza√ß√£o do ggplot. Os exemplos abaixo ser√£o apresentados em R, mas voc√™ pode sem nenhum problema executar os c√≥digos em Python atrav√©s da biblioteca plotnine. 4.1 O que √© o ggplot? Bom, ggplot √© um pacote em R criado por Hadley Wickham e seus colaboradores, como mencionado anteriormente, sua sintaxe se baseia na obra The Grammar of Graphics. Assim, a gram√°tica dos gr√°ficos √© um conjunto de camadas, cujo o mapeamento dos atributos √© chamado de aesthetics. O esqueleto pode ser escrito assim: ggplot(data = &lt;DATA&gt;, aes(&lt;MAPPINGS&gt;)) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; Vamos explicar linha por linha do c√≥digo acima. Vamos l√° üßÆ. 4.2 Mapeamento Est√©tico A est√©tica refere-se a cada aspecto de um dado elemento gr√°fico. Descrevemos as posi√ß√µes (position) por um valor x e y, mas outros sistemas de coordenadas s√£o poss√≠veis. √â poss√≠vel alterar a forma (shape), tamanho (size) e cor (size) dos elementos (Wilke 2019). A imagem abaixo, retirada do livro do Wilke (2019), mostra os componentes do mapeamento est√©tico. Vamos come√ßar criando um Data frame, deste modo: # importa√ß√£o do pacote tibble library(tibble) escola &lt;- tibble::tibble( aluno_id = c(1, 2, 3, 4, 5, 6), aluno_sexo = c(&quot;Masculino&quot;, &quot;Feminino&quot;,&quot;Masculino&quot;, &quot;Feminino&quot;, &quot;Masculino&quot;, &quot;Feminino&quot;), aluno_curso = c(&quot;Historia&quot;, &quot;Historia&quot;, &quot;Matem√°tica&quot;, &quot;Estat√≠stica&quot;, &quot;Matem√°tica&quot;, &quot;Estat√≠stica&quot;), aluno_media = c(2.1, 3.5, 4.0, 1.0, NA, 4.9), aluno_avaliacao = c(&quot;Ruim&quot;, &quot;Ruim&quot;, &quot;Excelente&quot;, &quot;Ruim&quot;, &quot;Nenhum&quot;, &quot;Excelente&quot;)) aluno_id aluno_sexo aluno_curso aluno_media aluno_avaliacao 1 Masculino Historia 2.1 Ruim 2 Feminino Historia 3.5 Ruim 3 Masculino Matem√°tica 4.0 Excelente 4 Feminino Estat√≠stica 1.0 Ruim 5 Masculino Matem√°tica NA Nenhum 6 Feminino Estat√≠stica 4.9 Excelente Agora, vamos mapear os atributos do nosso Data Frame escola, desta forma: # Importa√ß√£o do pacote ggplot2 library(ggplot2) # Mapeamento est√©tico ggplot(escola, aes(x=aluno_id, y=aluno_media, color=aluno_curso)) Bom, agora que mapeamos nossos atributos √© poss√≠vel ver que no eixo x est√° escrito aluno_id e no eixo y est√° escrito aluno_media. 4.3 Objetos geom√©tricos Os objetos geom√©tricos representam os objetos a serem adicionados no gr√°ficos, por exemplo, pontos (geom_point), colunas (geom_col), linha (geom_line). Observe que, os objetos geom√©tricos s√£o sufixos do m√©todos geom_. A tabela abaixo, retirada do livro Ci√™ncia de dados em R, mostra os tipos geom√©tricos mais comuns: Tipo Objeto Geom√©trico Dispers√£o (scatterplot) geom_point() Gr√°fico de pontos geom_point() Gr√°fico de barras Histograma geom_bar() e geom_col() geom_histogram() Boxplot geom_boxplot() Densidade geom_density() Gr√°fico de linhas geom_line() Vamos utilizar geom_point para fazer um gr√°fico de pontos no conjunto de dados, deste modo: # Adi√ß√£o de um objeto geom√©trico ggplot(escola, aes(x=aluno_id, y=aluno_media, color=aluno_curso)) + geom_point(na.rm = TRUE) Olha que legal. No entanto, ainda faltam informa√ß√µes no nosso gr√°ficos, por exemplo, no eixo x n√£o sabemos se come√ßa com 0 ou 1 e o nome dos atributos n√£o est√£o informativos. 4.4 Escalas Bom, agora √© a hora de melhorar nosso gr√°fico, que por sinal est√° bem estranho, vamos l√°! O ggplot cria as escalas de forma autom√°tica, no entanto, √© interessante ajustar as escalas para manter o gr√°fico mais fidedigno em rela√ß√£o aos seus eixos. Primeiro, vamos mudar o nome dos nossos atributos em cada eixo e tamb√©m alterar as escalas: # Adi√ß√£o de escalas no eixo x e y ggplot(escola, aes(x=aluno_id, y=aluno_media, color=aluno_curso)) + geom_point(na.rm = TRUE) + scale_x_continuous(name = &quot;Identifica√ß√£o dos alunos&quot;, breaks = 1:6) + scale_y_continuous(name=&quot;M√©dia dos alunos&quot;, breaks = seq(1, 6, 0.5)) Como as vari√°veis utilizadas s√£o cont√≠nuas, podemos utilizar a fun√ß√£o scale_x_continuous. Caso seja uma vari√°vel categ√≥rica, por exemplo, o nome dos alunos, usamos scale_x_discrete. Ainda falta mais informa√ß√µes, por exemplo, o t√≠tulo do nosso gr√°fico e melhorar a legenda. # Defini√ß√£o de cores para cada disciplina cores &lt;- c(&quot;Estat√≠stica&quot; = &quot;green&quot;, &quot;Historia&quot; = &quot;red&quot;, &quot;Matem√°tica&quot; = &quot;blue&quot;) # Altera√ß√£o da legenda e adi√ß√£o de um t√≠tulo ggplot(escola, aes(x=aluno_id, y=aluno_media, color=aluno_curso)) + geom_point(na.rm = TRUE) + scale_x_continuous(name = &quot;Identifica√ß√£o dos alunos&quot;, breaks = 1:6) + scale_y_continuous(name=&quot;M√©dia dos alunos&quot;, breaks = seq(1, 6, 0.5)) + scale_color_manual(&quot;Disciplinas&quot;, values = cores) + ggtitle(&quot;M√©dia dos alunos da faculdade&quot;) √â poss√≠vel observar que o aluno com id 5 n√£o possui m√©dia em nenhuma disciplina. Agora, que tal dividirmos nosso gr√°fico em sub gr√°ficos? üÜí. 4.5 Subplots (facet) Podemos dividir nosso gr√°fico em subgr√°ficos utilizandos as fun√ß√µes facet_grid e facet_wrap: -facet_grid: Forma uma matriz de pain√©is definidos por linhas e colunas. √â mais √∫til quando se tem duas vari√°veis discretas, e todas as combina√ß√µes das vari√°veis existem nos dados. -facet_wrap: Converte pain√©is de uma dimens√£o para duas dimens√µes. Defini√ß√µes retiradas da documenta√ß√£o e do livro Oliveira, Guerra, and Mcdonell (2018). # Defini√ß√£o de cores para cada disciplina cores &lt;- c(&quot;Estat√≠stica&quot; = &quot;green&quot;, &quot;Historia&quot; = &quot;red&quot;, &quot;Matem√°tica&quot; = &quot;blue&quot;) # Craia√ß√£o de subgr√°ficos pela avalia√ß√£o de cada aluno ggplot(escola, aes(x=aluno_sexo, y=aluno_media, color=aluno_curso)) + geom_point(na.rm = TRUE) + facet_grid(~ aluno_avaliacao) + labs(title=&quot;Notas dos alunos por grid&quot;, x = &quot;Sexo dos alunos&quot;, y = &quot;M√©dia dos alunos&quot;) + scale_color_manual(&quot;Mat√©rias&quot;, values = cores) Usamos o labs para mostrar que essa fun√ß√£o tamb√©m altera o nome dos eixos e o t√≠tulo 4.6 Temas Por √∫ltimo, vamos deixar nosso gr√°fico mais elegante, usando os temas do pr√≥prio pacote: # Defini√ß√£o de cores para cada disciplina cores &lt;- c(&quot;Estat√≠stica&quot; = &quot;green&quot;, &quot;Historia&quot; = &quot;red&quot;, &quot;Matem√°tica&quot; = &quot;blue&quot;) # Adi√ß√£o do tema &quot;theme_bw()&quot; ggplot(escola, aes(x=aluno_id, y=aluno_media, color=aluno_curso)) + geom_point(na.rm = TRUE) + scale_x_continuous(name = &quot;Identifica√ß√£o dos alunos&quot;, breaks = 1:6) + scale_y_continuous(name=&quot;M√©dia dos alunos&quot;, breaks = seq(1, 6, 0.5)) + scale_color_manual(&quot;Mat√©rias&quot;, values = cores) + ggtitle(&quot;M√©dia dos alunos da faculdade&quot;) + theme_bw() 4.7 Exemplos Nesta subse√ß√£o vamos usar conjuntos de dados reais para demonstrar o uso do ggplot2 com mais exemplos. 4.7.1 Gr√°fico de coordenadas paralelas # importa√ß√£o dos pacotes usados library(tidyr) library(dplyr) # Uso dos dados da iris data(&quot;iris&quot;) # Cria√ß√£o do gr√°fico de coordenadas paralelas iris %&gt;% dplyr::mutate(id = 1:nrow(iris)) %&gt;% # Cria√ß√£o de um atributo id tidyr::gather(atributos, valores, -Species, -id) %&gt;% # Transformando em wide para long ggplot(., aes(x = atributos, y = valores, color = Species, group = id)) + # mapeamento est√©tico geom_line(size=0.55) + # Objeto geom√©trico labs(x = &quot;Atributos&quot;, y = &quot;Valores&quot;, title = &quot;Coordenadas Paralelas - Iris&quot;, caption = &quot;Fonte: dataAt&quot;) + # legendas theme_bw() + # Adi√ß√£o do tema &quot;theme_bw()&quot; theme(plot.title = element_text(hjust= 0.5, margin = margin(b = 7))) Assim como apresentado anteriormente, podemos dividir nosso gr√°fico em subgr√°ficos, desta forma: # Cria√ß√£o do gr√°fico de coordenadas paralelas iris %&gt;% dplyr::mutate(id = 1:nrow(iris)) %&gt;% tidyr::gather(atributos, valores, -Species, -id) %&gt;% ggplot(., aes(x = atributos, y = valores, color = Species, group = id)) + geom_line(size=0.55) + facet_grid(~Species) + labs(x = &quot;Atributos&quot;, y = &quot;Valores&quot;, title = &quot;Coordenadas Paralelas - Iris&quot;) + theme_bw() + theme(plot.title = element_text(hjust= 0.5, margin = margin(b = 7)), axis.text.x = element_text(angle = 90)) Observe que, todos os conte√∫dos abordados neste livro est√£o sendo utilizados nos gr√°ficos apresentados acima. 4.8 Gr√°fico de colunas Para criar nosso gr√°fico de colunas vamos utilizar o conjunto de dados de tempestade, desta forma: # Importa√ß√£o dos dados como vari√°vel de ambiente storms &lt;- dplyr::storms # Visualiza√ß√£o dos dados head(storms, 5) ## # A tibble: 5 x 13 ## name year month day hour lat long status category wind pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropi‚Ä¶ -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropi‚Ä¶ -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropi‚Ä¶ -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropi‚Ä¶ -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropi‚Ä¶ -1 25 1012 ## # ‚Ä¶ with 2 more variables: ts_diameter &lt;dbl&gt;, hu_diameter &lt;dbl&gt; Para mais informa√ß√µes do conjunto de dados, basta utilizar ?dplyr::storms Como podemos observar, o dado consiste em um s√©rie temporal de tempestades registradas. Qual √© o tipo de tempestade mais recorrente? # Temas para o pacote ggplot2 library(cowplot) library(forcats) storms %&gt;% dplyr::group_by(status) %&gt;% dplyr::summarise(count = n()) %&gt;% dplyr::mutate(status = forcats::fct_reorder(status, count)) %&gt;% ggplot(., aes(x = status, y = count)) + geom_col(width = 0.5) + theme_minimal_hgrid() + labs(x = &quot;Tipos de tempestade&quot;, y = &quot;Quantidade&quot;, title = &quot;Gr√°fico de colunas - Storms&quot;) + theme(plot.title = element_text(hjust= 0.5, margin = margin(b = 7))) O pacote ggplot2 possui diversas extens√µes oficiais, as quais implementam diversos m√©todos de visualiza√ß√£o. No pr√≥ximo exemplo vamos usar a extes√£o Lemon. 4.9 Extens√£o do ggplot2 - Lemon Nesta subse√ß√£o vamos utilizar os dados dos pre√ßos de diamantes, podemos import√°-lo desta forma: # Importa√ß√£o do conjunto de dados como vari√°vel de ambiente diamonds &lt;- ggplot2::diamonds # Visualiza√ß√£o das cinco primeiras observa√ß√µes head(diamonds, 5) ## # A tibble: 5 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 Vamos utilizar os atributos cut, price e clarity, correspodentes a qualidade do corte do diamente, ao pre√ßo e a medi√ß√£o de qualidade, respectivamente. # importa√ß√£o do pacote Lemon library(lemon) # Defini√ß√£o da semente para garantir reprodutibilidade set.seed(123) # amostragem dos dados amost &lt;- sample(c(1:nrow(diamonds)), nrow(diamonds)*0.1, replace = FALSE) amost_diam &lt;- diamonds[amost,] amost_diam %&gt;% ggplot(., aes(x = as.factor(cut), y = price, color = clarity)) + geom_point(position=position_jitter(width=0.08)) + coord_flex_cart(bottom=brackets_horisontal(), left=capped_vertical(&#39;both&#39;)) + theme_light() + theme(panel.border=element_blank(), axis.line = element_line(), plot.title = element_text(hjust= 0.5, margin = margin(b = 7))) + labs(x = &quot;Qualidade do corte&quot;, y = &quot;Pre√ßo em US&quot;, title = &quot;Gr√°fico de bolhas - Diamonds&quot;) Bom, sabemos que o ggplot √© bem completo, mas, s√≥ abordamos uma pequena parcela. Com o tempo vamos adicionando mais materiais. Para se aprofundar no pacote, veja nossas an√°lises no dataAt üíÉ. 4.10 Para saber mais Alguns links √∫teis Tipos de gr√°ficos Ciencia de dados em R dataviz Escolhendo seus gr√°ficos "],
["references.html", "5 References", " 5 References "]
]
